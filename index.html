<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XR çº¯å‡€ä¿®å¤ç‰ˆ</title>
    <style>
        body { margin: 0; background-color: #000; color: white; font-family: sans-serif; }
        /* è¿™ä¸ªç•Œé¢åªåœ¨è¿›å…¥ AR ä¹‹å‰æ˜¾ç¤ºï¼Œè¿›å…¥åä¼šå®Œå…¨æ¶ˆå¤± */
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: #111; z-index: 10;
        }
        button {
            padding: 20px 50px; font-size: 24px; background: #00ff00; border: none; border-radius: 10px; font-weight: bold;
        }
        p { color: #aaa; margin-top: 10px; }
    </style>
    <!-- ä½¿ç”¨ç¨³å®šçš„ CDN -->
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<div id="launcher">
    <h1>ğŸš€ çº¯å‡€å¯åŠ¨æ¨¡å¼</h1>
    <button id="btn-enter">ç‚¹å‡»è¿›å…¥ AR</button>
    <p>å»é™¤ DOM Overlayï¼Œé˜²æ­¢å´©æºƒ</p>
</div>

<script type="module">
    import * as THREE from 'three';

    let camera, scene, renderer;
    let hand1, hand2;
    let particles, particleGeo;
    let particleOriginalPos = [];
    const particleCount = 1000;
    
    // å¼ºåˆ¶æ˜¾ç¤ºå®¹å™¨
    let stage;

    document.getElementById('btn-enter').addEventListener('click', onEnter);

    async function onEnter() {
        if (!navigator.xr) return alert("ä¸æ”¯æŒ WebXR");
        
        try {
            // ã€å…³é”®ä¿®æ”¹ã€‘å»æ‰äº† dom-overlayï¼Œåªè¯·æ±‚æœ€åŸºç¡€çš„åŠŸèƒ½
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local'], 
                optionalFeatures: ['hand-tracking'] // æ‰‹åŠ¿ä½œä¸ºå¯é€‰é¡¹ï¼Œä¸æ”¯æŒä¹Ÿä¸ä¼šå´©
            });
            
            // éšè—å¯åŠ¨ç•Œé¢
            document.getElementById('launcher').style.display = 'none';
            
            initThree(session);
        } catch (e) {
            alert("å¯åŠ¨å¤±è´¥: " + e.message);
        }
    }

    function initThree(session) {
        // 1. åˆå§‹åŒ–åœºæ™¯
        scene = new THREE.Scene();
        scene.background = null; // é€æ˜èƒŒæ™¯

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local'); // ä»¥å¤´ä¸ºåŸç‚¹
        renderer.xr.setSession(session);
        
        // session å…³é—­æ—¶çš„æ¸…ç†é€»è¾‘ï¼Œé˜²æ­¢æŠ¥é‚£ä¸ª null é”™è¯¯
        session.addEventListener('end', () => {
            renderer.setAnimationLoop(null);
            document.getElementById('launcher').style.display = 'flex';
        });

        // 2. åˆ›å»ºä¸€ä¸ªå§‹ç»ˆè·Ÿéšå¤´éƒ¨çš„å®¹å™¨
        stage = new THREE.Group();
        // ä½ç½®ï¼šæ­£å‰æ–¹ 0.4 ç±³ï¼Œç¨å¾®ä½ä¸€ç‚¹ç‚¹ä¾¿äºè§‚å¯Ÿ
        stage.position.set(0, -0.1, -0.4); 
        scene.add(stage);

        // 3. æ·»åŠ ä¸€ä¸ªå·¨å¤§çš„çº¢è‰²çº¿æ¡†ç«‹æ–¹ä½“ (ç»å¯¹å‚ç…§ç‰©)
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.2, 0.2),
            new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
        );
        stage.add(box);

        // 4. åˆ›å»ºç²’å­
        createParticles();

        // 5. æ‰‹éƒ¨è¿½è¸ª
        hand1 = renderer.xr.getHand(0); scene.add(hand1);
        hand2 = renderer.xr.getHand(1); scene.add(hand2);

        // 6. å¯åŠ¨å¾ªç¯
        renderer.setAnimationLoop(render);
    }

    function createParticles() {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        for (let i = 0; i < particleCount; i++) {
            // ç”Ÿæˆåœ¨ç›’å­å†…éƒ¨
            const x = (Math.random() - 0.5) * 0.2;
            const y = (Math.random() - 0.5) * 0.2;
            const z = (Math.random() - 0.5) * 0.2;
            positions.push(x, y, z);
            particleOriginalPos.push({x, y, z});
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        particleGeo = geometry;

        const material = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.01,
            blending: THREE.NormalBlending, // å¿…é¡»æ˜¯ Normalï¼Œå¦åˆ™ AR é‡Œçœ‹ä¸è§
            depthTest: false, // å¼ºåˆ¶åœ¨æœ€å‰ï¼Œä¸è¢«é®æŒ¡
            transparent: false
        });

        particles = new THREE.Points(geometry, material);
        stage.add(particles);
    }

    function getHandGesture(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist'] || !hand.joints['middle-finger-tip']) return 'neutral';
        const d = hand.joints['wrist'].position.distanceTo(hand.joints['middle-finger-tip'].position);
        if (d < 0.08) return 'fist';
        if (d > 0.12) return 'palm';
        return 'neutral';
    }

    function render() {
        // æ—‹è½¬æ•´ä¸ªèˆå°ï¼Œç¡®ä¿¡å®ƒæ´»ç€
        if(stage) stage.rotation.y += 0.01;

        // æ‰‹åŠ¿é€»è¾‘
        let gesture = 'neutral';
        const g1 = getHandGesture(hand1);
        const g2 = getHandGesture(hand2);
        if (g1 !== 'neutral' && g1 !== 'none') gesture = g1;
        else if (g2 !== 'neutral' && g2 !== 'none') gesture = g2;

        // ç²’å­åé¦ˆ
        if (particles) {
            const positions = particleGeo.attributes.position.array;
            
            if (gesture === 'palm') particles.material.color.setHex(0xffcc00); // ç‚¸å¼€å˜é»„
            else if (gesture === 'fist') particles.material.color.setHex(0xff0000); // æ¡æ‹³å˜çº¢
            else particles.material.color.setHex(0x00ffff); // é»˜è®¤é’è‰²

            for(let i=0; i<particleCount; i++) {
                const ix = i * 3;
                const ox = particleOriginalPos[i].x;
                const oy = particleOriginalPos[i].y;
                const oz = particleOriginalPos[i].z;
                
                let scale = 1.0;
                if (gesture === 'palm') scale = 2.0;
                if (gesture === 'fist') scale = 0.1;

                positions[ix] += (ox * scale - positions[ix]) * 0.1;
                positions[ix+1] += (oy * scale - positions[ix+1]) * 0.1;
                positions[ix+2] += (oz * scale - positions[ix+2]) * 0.1;
            }
            particleGeo.attributes.position.needsUpdate = true;
        }

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
