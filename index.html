<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XR å®Œç¾æµä½“</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #222, #000);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 999;
        }
        h1 { background: linear-gradient(to right, #00ffff, #ff00ff); -webkit-background-clip: text; color: transparent; margin-bottom: 20px;}
        button {
            padding: 20px 60px; font-size: 20px; border-radius: 50px; border: none;
            background: white; color: black; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        .status { margin-top: 20px; color: #888; font-size: 14px; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<div id="launcher">
    <h1>ğŸ’« å¼•åŠ›æµä½“åœº</h1>
    <button id="btn-enter">å¯åŠ¨ä½“éªŒ</button>
    <div class="status">å‰3ç§’é”å®šä½ç½®ï¼Œé˜²æ­¢é£æ•£</div>
</div>

<script type="module">
    import * as THREE from 'three';

    let camera, scene, renderer;
    let hand1, hand2;
    let stage;
    let meshSystem, dummy = new THREE.Object3D();

    // ç²’å­è®¾ç½®
    const PARTICLE_COUNT = 2500; // æ•°é‡é€‚ä¸­
    const PARTICLE_SIZE = 0.008; // 8æ¯«ç±³å°çƒï¼Œæ¯”æ–¹å—ç²¾è‡´ï¼Œä½†è‚‰çœ¼å¯è§
    
    // ç‰©ç†æ•°ç»„
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const vel = new Float32Array(PARTICLE_COUNT * 3);
    const originalPos = new Float32Array(PARTICLE_COUNT * 3);

    // æ‰‹éƒ¨æ•°æ®
    const handsData = [
        { pos: new THREE.Vector3(), vel: new THREE.Vector3(), lastPos: new THREE.Vector3(), active: false },
        { pos: new THREE.Vector3(), vel: new THREE.Vector3(), lastPos: new THREE.Vector3(), active: false }
    ];

    // æ—¶é’Ÿ
    const clock = new THREE.Clock();

    document.getElementById('btn-enter').addEventListener('click', async () => {
        if (!navigator.xr) return alert("ä¸æ”¯æŒ XR");
        try {
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local'],
                optionalFeatures: ['hand-tracking']
            });
            document.getElementById('launcher').style.display = 'none';
            initThree(session);
        } catch (e) {
            alert("å¯åŠ¨å¤±è´¥: " + e.message);
        }
    });

    function initThree(session) {
        scene = new THREE.Scene();
        scene.background = null;

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.05, 100);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);

        session.addEventListener('end', () => {
            renderer.setAnimationLoop(null);
            document.getElementById('launcher').style.display = 'flex';
        });

        // èˆå°ï¼šçœ¼å‰ 0.5 ç±³ï¼Œé«˜åº¦å¹³è§†
        stage = new THREE.Group();
        stage.position.set(0, -0.1, -0.5); 
        scene.add(stage);

        // 1. çº¢æ¡† (å®šä½é”šç‚¹ï¼Œä¿ç•™ç€ä»¥é˜²ä¸‡ä¸€ï¼Œä½†è®¾å¾—å¾ˆæ·¡)
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 0.5),
            new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.15 })
        );
        stage.add(box);

        // 2. åˆ›å»ºå®ä½“å°çƒç²’å­
        createSolidParticles();

        // 3. æ‰‹éƒ¨
        hand1 = renderer.xr.getHand(0); scene.add(hand1);
        hand2 = renderer.xr.getHand(1); scene.add(hand2);

        renderer.setAnimationLoop(render);
    }

    function createSolidParticles() {
        // ä½¿ç”¨ 20é¢ä½“ (Icosahedron) ä»£æ›¿æ–¹å—ï¼Œçœ‹èµ·æ¥åƒçƒï¼Œæ€§èƒ½å¥½
        const geometry = new THREE.IcosahedronGeometry(PARTICLE_SIZE, 0);
        
        // æè´¨ï¼šä¸é€æ˜å®ä½“ï¼Œä¿è¯èƒ½çœ‹è§
        // ä½¿ç”¨ vertexColors å¼€å¯å¤šå½©
        const material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            depthTest: true, // å¼€å¯æ·±åº¦æµ‹è¯•ï¼Œæœ‰å‰åé®æŒ¡å…³ç³»ï¼Œç«‹ä½“æ„Ÿæ›´å¼º
            depthWrite: true,
            transparent: false // ä¸¥ç¦é€æ˜
        });

        meshSystem = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);
        meshSystem.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        
        const c1 = new THREE.Color(0x00ffff); // é’
        const c2 = new THREE.Color(0xff00ff); // ç´«
        const c3 = new THREE.Color(0xffff00); // é»„

        for(let i=0; i<PARTICLE_COUNT; i++) {
            // çƒå½¢éšæœºåˆ†å¸ƒ
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = Math.cbrt(Math.random()) * 0.2; // åŠå¾„ 0.2ç±³

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            pos[i*3] = x; pos[i*3+1] = y; pos[i*3+2] = z;
            originalPos[i*3] = x; originalPos[i*3+1] = y; originalPos[i*3+2] = z;
            vel[i*3] = 0; vel[i*3+1] = 0; vel[i*3+2] = 0;

            dummy.position.set(x,y,z);
            dummy.updateMatrix();
            meshSystem.setMatrixAt(i, dummy.matrix);
            
            // éšæœºåˆ†é…ä¸‰ç§ç³–æœè‰²
            const rand = Math.random();
            const color = new THREE.Color();
            if(rand < 0.33) color.copy(c1);
            else if(rand < 0.66) color.copy(c2);
            else color.copy(c3);
            
            // ç¨å¾®è®©é¢œè‰²æœ‰ä¸€äº›äº®åº¦å·®å¼‚
            color.multiplyScalar(0.8 + Math.random() * 0.4);
            meshSystem.setColorAt(i, color);
        }
        
        stage.add(meshSystem);
    }

    function updateHand(hand, data) {
        // ä¸¥è°¨çš„æ‰‹éƒ¨æ£€æµ‹ï¼šå¿…é¡»åæ ‡ä¸ä¸º0
        if(hand?.joints?.['index-finger-tip']?.position?.length() > 0.01) {
            const worldPos = new THREE.Vector3();
            hand.joints['index-finger-tip'].getWorldPosition(worldPos);
            
            // åªæœ‰å½“æ‰‹çœŸæ­£é è¿‘èˆå°æ—¶æ‰æ¿€æ´» (é¿å…è¿œå¤„çš„è¯¯è§¦)
            if (worldPos.distanceTo(stage.position) < 1.0) {
                const localPos = worldPos.clone().sub(stage.position);
                data.active = true;
                data.pos.copy(localPos);
                
                if(data.lastPos.lengthSq() > 0) {
                    data.vel.copy(data.pos).sub(data.lastPos).multiplyScalar(3.0);
                }
                data.lastPos.copy(data.pos);
                return;
            }
        }
        data.active = false;
        // é‡ç½®ä¸Šä¸€å¸§ä½ç½®ï¼Œé˜²æ­¢ç¬ç§»äº§ç”Ÿçš„å·¨å¤§é€Ÿåº¦
        data.lastPos.set(0,0,0);
    }

    function getGesture(hand) {
        if(!hand?.joints?.['wrist'] || !hand?.joints?.['middle-finger-tip']) return 'neutral';
        const d = hand.joints['wrist'].position.distanceTo(hand.joints['middle-finger-tip'].position);
        // åªæœ‰æ‰‹åæ ‡æœ‰æ•ˆæ—¶æ‰åˆ¤æ–­
        if (hand.joints['wrist'].position.length() < 0.01) return 'neutral';
        
        if(d < 0.08) return 'fist';
        if(d > 0.12) return 'palm';
        return 'neutral';
    }

    function render() {
        const time = clock.getElapsedTime();
        
        // 1. å¯åŠ¨ä¿æŠ¤æœŸ (å‰3ç§’)
        // å¼ºåˆ¶æ‰€æœ‰ç²’å­å›åˆ°åŸä½ï¼Œä¸”ä¸è¿›è¡Œç‰©ç†è®¡ç®—
        if (time < 3.0) {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const ix = i*3;
                dummy.position.set(originalPos[ix], originalPos[ix+1], originalPos[ix+2]);
                // è®©å®ƒä»¬è½¬ä¸€è½¬ï¼Œè¡¨ç¤ºæ´»ç€
                dummy.rotation.x = time + i; 
                dummy.updateMatrix();
                meshSystem.setMatrixAt(i, dummy.matrix);
            }
            meshSystem.instanceMatrix.needsUpdate = true;
            
            // æ—‹è½¬çº¢æ¡†æç¤º
            stage.children[0].rotation.y += 0.05;
            renderer.render(scene, camera);
            return; // è·³è¿‡åç»­é€»è¾‘
        }

        // --- æ­£å¸¸ç‰©ç†é€»è¾‘ ---
        
        updateHand(hand1, handsData[0]);
        updateHand(hand2, handsData[1]);

        let gesture = 'neutral';
        const g1 = getGesture(hand1); const g2 = getGesture(hand2);
        if(g1 !== 'neutral') gesture = g1; else if(g2 !== 'neutral') gesture = g2;

        const returnForce = 0.04; // å¢å¼ºå›å®¶å¼•åŠ›
        const friction = 0.90;    // é˜»åŠ›
        const maxVel = 0.03;      // ã€å…³é”®ã€‘é€Ÿåº¦ä¸Šé™ (ç±³/å¸§)ï¼Œé˜²æ­¢é£é£

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i*3;
            let px = pos[ix], py = pos[ix+1], pz = pos[ix+2];
            let vx = vel[ix], vy = vel[ix+1], vz = vel[ix+2];

            // 1. æµä½“äº¤äº’
            for(let h=0; h<2; h++) {
                if(handsData[h].active) {
                    const dx = px - handsData[h].pos.x;
                    const dy = py - handsData[h].pos.y;
                    const dz = pz - handsData[h].pos.z;
                    const dSq = dx*dx + dy*dy + dz*dz;
                    
                    // 15å˜ç±³å½±å“èŒƒå›´
                    if(dSq < 0.0225) { 
                        const d = Math.sqrt(dSq);
                        const f = (1 - d/0.15); // åŠ›åº¦æ¢¯åº¦

                        // æ–¥åŠ› (æ¨å¼€)
                        vx += (dx/d) * f * 0.005; 
                        vy += (dy/d) * f * 0.005;
                        vz += (dz/d) * f * 0.005;
                        
                        // æ‹–æ‹½åŠ› (è·Ÿéš)
                        vx += handsData[h].vel.x * f * 0.1;
                        vy += handsData[h].vel.y * f * 0.1;
                        vz += handsData[h].vel.z * f * 0.1;
                    }
                }
            }

            // 2. æ‰‹åŠ¿åŠ›åœº
            if(gesture === 'fist') {
                // å¼ºåŠ›é»‘æ´
                vx -= px * 0.05; vy -= py * 0.05; vz -= pz * 0.05;
            } else if(gesture === 'palm') {
                // çˆ†ç‚¸
                vx += px * 0.03; vy += py * 0.03; vz += pz * 0.03;
                // åŠ ç‚¹éšæœºæŠ–åŠ¨
                vx += (Math.random()-0.5)*0.01;
            } else {
                // å›å®¶ (å¼¹ç°§)
                vx += (originalPos[ix] - px) * returnForce;
                vy += (originalPos[ix+1] - py) * returnForce;
                vz += (originalPos[ix+2] - pz) * returnForce;
            }

            // 3. ç‰©ç†åº”ç”¨ & é™é€Ÿ
            vx *= friction; vy *= friction; vz *= friction;

            // ã€å…³é”®ã€‘é€Ÿåº¦é’³åˆ¶
            if (vx > maxVel) vx = maxVel; if (vx < -maxVel) vx = -maxVel;
            if (vy > maxVel) vy = maxVel; if (vy < -maxVel) vy = -maxVel;
            if (vz > maxVel) vz = maxVel; if (vz < -maxVel) vz = -maxVel;

            px += vx; py += vy; pz += vz;

            pos[ix] = px; pos[ix+1] = py; pos[ix+2] = pz;
            vel[ix] = vx; vel[ix+1] = vy; vel[ix+2] = vz;

            // æ›´æ–°çŸ©é˜µ
            dummy.position.set(px, py, pz);
            // æ ¹æ®é€Ÿåº¦æ‹‰ä¼¸ (Motion Blur è§†è§‰æ¬ºéª—)
            // dummy.scale.set(1 + Math.abs(vx)*10, 1, 1); 
            dummy.updateMatrix();
            meshSystem.setMatrixAt(i, dummy.matrix);
            
            // å˜è‰²åé¦ˆ
            if (gesture === 'palm') {
                meshSystem.setColorAt(i, new THREE.Color(0xffaa00)); // é‡‘
            } else if (gesture === 'fist') {
                meshSystem.setColorAt(i, new THREE.Color(0xff0000)); // çº¢
            } else {
                // æ ¹æ®åŸå§‹é¢œè‰² + é€Ÿåº¦å˜äº®
                // è¿™é‡Œä¸ºäº†æ€§èƒ½ç®€åŒ–ï¼Œä¸å›æ»šåŸå§‹é¢œè‰²ï¼Œè€Œæ˜¯ç›´æ¥åœ¨ render loop é‡Œä¸æ“ä½œ
                // (InstancedMesh çš„é¢œè‰²å¦‚æœä¸ set å°±ä¿æŒåŸæ ·)
            }
        }
        
        // åªæœ‰åœ¨æ‰‹åŠ¿è§¦å‘æ—¶æ‰æ‰¹é‡æ›´æ–°é¢œè‰²ï¼Œå¹³æ—¶ä¿æŒäº”é¢œå…­è‰²
        if (gesture !== 'neutral') {
             meshSystem.instanceColor.needsUpdate = true;
        }

        meshSystem.instanceMatrix.needsUpdate = true;
        
        stage.children[0].rotation.y += 0.005;
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
