<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Vegeta Scouter Ultimate</title>
    <!-- 引入龙珠风格字体 -->
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+QingKe+HuangYou&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'ZCOOL QingKe HuangYou', sans-serif; }
        
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 0, 0, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 999; color: #ffaa00;
        }

        button {
            padding: 15px 50px; font-size: 28px; 
            color: #000; background: #ffaa00; border: none; 
            border-radius: 2px; cursor: pointer; margin-top: 30px;
            box-shadow: 0 0 25px #ff4400; 
            font-family: 'ZCOOL QingKe HuangYou', cursive; letter-spacing: 2px;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        #hud-status {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            color: #ffaa00; font-size: 24px; pointer-events: none; 
            text-shadow: 0 0 5px #ff0000; display: none; letter-spacing: 3px;
        }

        .font-preload { opacity: 0; position: absolute; font-family: 'ZCOOL QingKe HuangYou', cursive; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div class="font-preload">战斗力探测仪极度危险警惕一般般</div>

<div id="launcher">
    <h1 style="text-shadow: 0 0 20px #ff0000; font-size: 48px; margin: 0; letter-spacing: 5px;">赛亚人探测器</h1>
    <div style="border-left: 5px solid #ff4400; padding-left: 20px; margin-top: 20px;">
        <p style="color: #fff; opacity: 0.9; font-size: 22px; margin: 5px 0;">目标：贝吉塔 (VEGETA)</p>
        <p style="color: #ffaa00; font-size: 18px; margin: 5px 0;">系统版本：v3.0 动态锁定</p>
    </div>
    <button id="btn-start">启动 HUD</button>
</div>

<div id="hud-status">等待目标...</div>

<script type="module">
    import * as THREE from 'three';
    import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

    let camera, scene, renderer;
    let handLeft, handRight;
    
    // 视觉对象
    let aimCursor;
    let targetGroup;    
    let powerSprite;    
    let laserPlane;     
    
    // 逻辑控制
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let isLocked = false;
    let scanInterval = null;
    let animationStartTime = 0; // 动画开始时间

    // UI 配置
    const THEME_COLOR = "#ffaa00"; 
    const THEME_BG = "rgba(20, 0, 0, 0.85)"; 
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 256;

    // --- 缓动函数 (让动画更有机械感) ---
    // t: 0-1
    function easeOutExpo(x) {
        return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
    }
    function easeOutBack(x) {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
    }

    document.getElementById('btn-start').addEventListener('click', initAR);

    async function initAR() {
        if (!navigator.xr) return alert("WebXR不支持");
        const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['local', 'hit-test'],
            optionalFeatures: ['hand-tracking', 'dom-overlay'],
            domOverlay: { root: document.body }
        });
        document.getElementById('launcher').style.display = 'none';
        document.getElementById('hud-status').style.display = 'block';
        initScene(session);
    }

    function initScene(session) {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);
        session.addEventListener('end', () => location.reload());

        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(0, 5, 2);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // 十字准星
        const cursorTexture = createCursorTexture();
        const cursorMat = new THREE.SpriteMaterial({ map: cursorTexture, color: 0xffffff, transparent: true, opacity: 0.9 });
        aimCursor = new THREE.Sprite(cursorMat);
        aimCursor.scale.set(0.08, 0.08, 1);
        aimCursor.visible = false;
        scene.add(aimCursor);

        createTargetVisuals();
        setupHands();

        renderer.setAnimationLoop(render);
    }

    function createCursorTexture() {
        const cvs = document.createElement('canvas');
        cvs.width = 128; cvs.height = 128;
        const c = cvs.getContext('2d');
        c.strokeStyle = '#ffffff';
        c.lineWidth = 6;
        c.beginPath(); c.moveTo(64, 20); c.lineTo(64, 108); c.stroke();
        c.beginPath(); c.moveTo(20, 64); c.lineTo(108, 64); c.stroke();
        c.beginPath(); c.arc(64, 64, 40, 0, Math.PI*2); c.stroke();
        return new THREE.CanvasTexture(cvs);
    }

    function createTargetVisuals() {
        targetGroup = new THREE.Group();
        targetGroup.visible = false;
        scene.add(targetGroup);

        // A. 战术框 (L型)
        const bracketGeo = new THREE.BufferGeometry();
        const s = 0.3; 
        const vertices = new Float32Array([
            -s, s, 0,  -s+0.1, s, 0,  -s, s, 0,  -s, s-0.1, 0,
             s, s, 0,   s-0.1, s, 0,   s, s, 0,   s, s-0.1, 0,
            -s, -s, 0, -s+0.1, -s, 0, -s, -s, 0, -s, -s+0.1, 0,
             s, -s, 0,  s-0.1, -s, 0,  s, -s, 0,  s, -s+0.1, 0
        ]);
        bracketGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        const bracketMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2, transparent: true, opacity: 0 });
        const brackets = new THREE.LineSegments(bracketGeo, bracketMat);
        brackets.name = "brackets";
        targetGroup.add(brackets);

        // B. 扫描激光
        const planeGeo = new THREE.PlaneGeometry(0.6, 0.02);
        const planeMat = new THREE.MeshBasicMaterial({ color: 0xff3300, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
        laserPlane = new THREE.Mesh(planeGeo, planeMat);
        laserPlane.name = "laser";
        targetGroup.add(laserPlane);

        // C. 纯白指针 (左右)
        const ptrGeo = new THREE.ConeGeometry(0.05, 0.15, 4);
        const ptrMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
        const leftPtr = new THREE.Mesh(ptrGeo, ptrMat);
        leftPtr.rotation.z = -Math.PI / 2; leftPtr.name = "leftPtr";
        targetGroup.add(leftPtr);

        const rightPtr = new THREE.Mesh(ptrGeo, ptrMat);
        rightPtr.rotation.z = Math.PI / 2; rightPtr.name = "rightPtr";
        targetGroup.add(rightPtr);
    }

    function setupHands() {
        const handModelFactory = new XRHandModelFactory();
        function buildHand(idx) {
            const hand = renderer.xr.getHand(idx);
            hand.add(handModelFactory.createHandModel(hand, "mesh"));
            hand.addEventListener('connected', () => {
                hand.traverse(child => {
                    if(child.isMesh) {
                        child.material = new THREE.MeshBasicMaterial({
                            color: 0xff5500, wireframe: true, transparent: true, opacity: 0.3
                        });
                    }
                });
            });
            scene.add(hand);
            return hand;
        }
        handLeft = buildHand(0);
        handRight = buildHand(1);
    }

    function updateCanvasUI(powerValue, isFinal) {
        ctx.clearRect(0, 0, 512, 256);

        // 动态展开效果
        ctx.globalAlpha = 1.0;

        ctx.fillStyle = THEME_BG;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(480, 0); ctx.lineTo(512, 32); 
        ctx.lineTo(512, 256); ctx.lineTo(32, 256); ctx.lineTo(0, 224); 
        ctx.closePath();
        ctx.fill();

        let borderColor = "#ffaa00"; 
        let dangerText = "正在分析...";
        
        if (isFinal) {
            if (powerValue < 9000) {
                borderColor = "#ffffff"; 
                dangerText = "一般般";
            } else if (powerValue >= 9000 && powerValue <= 18000) {
                borderColor = "#ffaa00"; 
                dangerText = "警惕！";
            } else {
                borderColor = "#ff0000"; 
                dangerText = "极度危险";
            }
        }

        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 6;
        ctx.stroke();

        ctx.strokeStyle = "rgba(255, 100, 0, 0.3)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(20, 60); ctx.lineTo(492, 60); ctx.stroke();
        
        ctx.font = "110px 'ZCOOL QingKe HuangYou'";
        ctx.textAlign = "center";
        ctx.shadowBlur = 15;
        ctx.shadowColor = borderColor;
        ctx.fillStyle = isFinal ? "#fff" : THEME_COLOR;
        ctx.fillText(powerValue, 256, 170);

        ctx.font = "32px 'ZCOOL QingKe HuangYou'";
        ctx.fillStyle = "#ffaa00";
        ctx.shadowBlur = 0;
        ctx.textAlign = "left";
        ctx.fillText("战斗力探测仪", 25, 45);

        ctx.textAlign = "right";
        ctx.fillStyle = borderColor; 
        ctx.fillText(dangerText, 485, 45);

        ctx.textAlign = "center";
        ctx.fillStyle = "#ffffff";
        ctx.font = "28px 'ZCOOL QingKe HuangYou'";
        const statusText = isFinal ? "目标已锁定" : "数据读取中...";
        ctx.fillText(statusText, 256, 225);
    }

    function triggerScan(position) {
        if (isLocked) return;
        isLocked = true;
        aimCursor.visible = false;
        animationStartTime = Date.now(); // 记录动画开始时间

        targetGroup.position.copy(position);
        targetGroup.lookAt(camera.position); 
        targetGroup.visible = true;

        // UI 位置
        const uiPos = position.clone().add(new THREE.Vector3(0, 0.65, 0));

        if (powerSprite) scene.remove(powerSprite);
        const texture = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0 }); // 初始透明
        powerSprite = new THREE.Sprite(mat);
        powerSprite.position.copy(uiPos);
        powerSprite.scale.set(0, 0, 0); // 初始大小为0
        scene.add(powerSprite);

        let steps = 0;
        const targetVal = 18000 + Math.floor(Math.random() * 6000); 

        scanInterval = setInterval(() => {
            steps++;
            const rnd = Math.floor(Math.random() * 25000);
            updateCanvasUI(rnd, false);
            texture.needsUpdate = true;

            if (steps > 40) { 
                clearInterval(scanInterval);
                updateCanvasUI(targetVal, true);
                texture.needsUpdate = true;
                
                if (targetVal > 18000) {
                    targetGroup.children[0].material.color.setHex(0xff0000); 
                } else if (targetVal > 9000) {
                    targetGroup.children[0].material.color.setHex(0xffaa00);
                }
            }
        }, 50);
    }

    function resetSystem() {
        isLocked = false;
        clearInterval(scanInterval);
        targetGroup.visible = false;
        targetGroup.children[0].material.color.setHex(0xffffff); 
        if (powerSprite) {
            scene.remove(powerSprite);
            powerSprite = null;
        }
        document.getElementById('hud-status').innerText = "系统重置完成";
    }

    function isPointing(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;
        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        const middleTip = hand.joints['middle-finger-tip'].position;
        return wrist.distanceTo(indexTip) > 0.10 && wrist.distanceTo(middleTip) < 0.10;
    }

    function isFist(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;
        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        return wrist.distanceTo(indexTip) < 0.09;
    }

    function render(timestamp, frame) {
        if (frame) {
            const refSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();

            // Hit Test
            if (!hitTestSourceRequested) {
                session.requestReferenceSpace('viewer').then(ref => {
                    session.requestHitTestSource({ space: ref }).then(source => hitTestSource = source);
                });
                hitTestSourceRequested = true;
            }

            if (hitTestSource && !isLocked) {
                const hits = frame.getHitTestResults(hitTestSource);
                if (hits.length > 0) {
                    const pose = hits[0].getPose(refSpace);
                    aimCursor.visible = true;
                    aimCursor.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                } else {
                    aimCursor.visible = false;
                }
            }

            // 交互
            if (!isLocked && aimCursor.visible && isPointing(handRight)) {
                triggerScan(aimCursor.position);
            }
            if (isLocked && isFist(handLeft)) {
                resetSystem();
            }

            // --- 核心动效逻辑 ---
            if (isLocked && targetGroup.visible) {
                const time = Date.now();
                const progress = Math.min((time - animationStartTime) / 600, 1.0); // 0.6秒动画时长
                
                // 1. 战术框 (汇聚效果)
                const brackets = targetGroup.getObjectByName("brackets");
                // 从 2.5倍大小缩小到 1.0
                const scale = 2.5 - 1.5 * easeOutExpo(progress); 
                brackets.scale.set(scale, scale, scale);
                // 透明度渐变
                brackets.material.opacity = progress;

                // 2. 指针 (从远处飞入)
                const leftPtr = targetGroup.getObjectByName("leftPtr");
                const rightPtr = targetGroup.getObjectByName("rightPtr");
                // 从 ±1.5 飞到 ±0.5
                const flyDist = 1.5 - 1.0 * easeOutExpo(progress);
                leftPtr.position.x = -flyDist;
                rightPtr.position.x = flyDist;

                // 3. UI 面板 (全息展开)
                if (powerSprite) {
                    // 使用 Back 缓动函数，带点弹性的放大
                    const uiScale = easeOutBack(progress);
                    // 最终大小是 (1.0, 0.5, 1)
                    powerSprite.scale.set(1.0 * uiScale, 0.5 * uiScale, 1);
                    powerSprite.material.opacity = progress;
                }

                // 4. 激光待机动画
                const t = timestamp / 1000;
                const laser = targetGroup.getObjectByName("laser");
                laser.position.y = Math.sin(t * 3) * 0.25; // 快速上下扫描
                
                // 待机时的轻微浮动 (仅在入场动画结束后生效)
                if (progress === 1.0) {
                    leftPtr.position.x = -0.5 - Math.sin(t * 2) * 0.02; // 指针呼吸
                    rightPtr.position.x = 0.5 + Math.sin(t * 2) * 0.02;
                }
            }
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
