<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XR ç¨³å®šæµä½“ç‰ˆ</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 999;
        }
        button {
            padding: 20px 50px; font-size: 22px; border-radius: 10px; border: none;
            background: #00ff88; color: #000; font-weight: bold; cursor: pointer;
        }
        p { color: #888; margin-top: 20px; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<div id="launcher">
    <h1>ğŸ’§ ç¨³å®šæµä½“äº¤äº’</h1>
    <button id="btn-enter">å¯åŠ¨ AR</button>
    <p>å¦‚æœçœ‹åˆ°çº¢æ¡†ï¼Œè¯´æ˜å®šä½æˆåŠŸ</p>
</div>

<script type="module">
    import * as THREE from 'three';

    let camera, scene, renderer;
    let hand1, hand2;
    let stage;
    
    // ç²’å­ç³»ç»Ÿ
    let particles, particleGeo;
    const PARTICLE_COUNT = 2500; // é™ä½æ•°é‡ä¿å¹³å®‰
    
    // ç‰©ç†æ•°æ®
    const posOriginal = new Float32Array(PARTICLE_COUNT * 3);
    const velocity = new Float32Array(PARTICLE_COUNT * 3);
    
    // æ‰‹éƒ¨äº¤äº’æ•°æ®
    const handsData = [
        { pos: new THREE.Vector3(), vel: new THREE.Vector3(), lastPos: new THREE.Vector3(), active: false },
        { pos: new THREE.Vector3(), vel: new THREE.Vector3(), lastPos: new THREE.Vector3(), active: false }
    ];

    document.getElementById('btn-enter').addEventListener('click', onEnter);

    async function onEnter() {
        if (!navigator.xr) return alert("ä¸æ”¯æŒ XR");
        try {
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local'],
                optionalFeatures: ['hand-tracking']
            });
            document.getElementById('launcher').style.display = 'none';
            initThree(session);
        } catch (e) {
            alert("å¯åŠ¨é”™è¯¯: " + e.message);
        }
    }

    // ç”Ÿæˆå…‰ç‚¹çº¹ç†
    function createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        return new THREE.CanvasTexture(canvas);
    }

    function initThree(session) {
        scene = new THREE.Scene();
        scene.background = null;

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.05, 100);
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);

        session.addEventListener('end', () => {
            renderer.setAnimationLoop(null);
            document.getElementById('launcher').style.display = 'flex';
        });

        // --- èˆå° (å›ºå®šåœ¨é¢å‰) ---
        stage = new THREE.Group();
        stage.position.set(0, -0.2, -0.5); // çœ¼å‰ 0.5 ç±³
        scene.add(stage);

        // 1. ã€è¯Šæ–­ã€‘çº¢è‰²ç»†çº¿æ¡† (ç¡®ä¿ä½ çœ‹å¾—åˆ°ä½ç½®)
        // å¦‚æœä½ åªçœ‹åˆ°çº¢æ¡†æ²¡çœ‹åˆ°ç²’å­ï¼Œè¯´æ˜æè´¨æœ‰é—®é¢˜
        // å¦‚æœå•¥éƒ½æ²¡çœ‹åˆ°ï¼Œè¯´æ˜å®šä½æœ‰é—®é¢˜
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 0.5),
            new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.3 })
        );
        stage.add(box);

        // 2. ç²’å­ç³»ç»Ÿ
        createParticles();

        // 3. æ‰‹éƒ¨
        hand1 = renderer.xr.getHand(0); scene.add(hand1);
        hand2 = renderer.xr.getHand(1); scene.add(hand2);

        renderer.setAnimationLoop(render);
    }

    function createParticles() {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        
        const c1 = new THREE.Color(0x00ffff); // é’
        const c2 = new THREE.Color(0xff00ff); // ç´«

        for(let i=0; i<PARTICLE_COUNT; i++) {
            // éšæœºåˆ†å¸ƒåœ¨çƒä½“å†…
            const x = (Math.random()-0.5) * 0.4;
            const y = (Math.random()-0.5) * 0.4;
            const z = (Math.random()-0.5) * 0.4;

            positions.push(x, y, z);
            
            // ç‰©ç†åˆå§‹æ•°æ®
            posOriginal[i*3] = x;
            posOriginal[i*3+1] = y;
            posOriginal[i*3+2] = z;
            velocity[i*3] = 0;
            velocity[i*3+1] = 0;
            velocity[i*3+2] = 0;

            // é¢œè‰²
            const c = c1.clone().lerp(c2, Math.random());
            colors.push(c.r, c.g, c.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        particleGeo = geometry;

        const material = new THREE.PointsMaterial({
            size: 0.015,
            map: createGlowTexture(),
            vertexColors: true,
            transparent: true, 
            opacity: 1.0, // å¼ºåˆ¶ä¸é€æ˜åº¦
            blending: THREE.NormalBlending, // ç¨³å®šæ··åˆæ¨¡å¼
            depthWrite: false, // å…³é”®ï¼šé˜²æ­¢ç²’å­äº’ç›¸é®æŒ¡å˜æˆé»‘å—
            depthTest: true
        });

        particles = new THREE.Points(geometry, material);
        stage.add(particles);
    }

    // æ›´æ–°æ‰‹éƒ¨ç‰©ç†
    function updateHand(hand, data) {
        if(hand && hand.joints && hand.joints['index-finger-tip']) {
            const joint = hand.joints['index-finger-tip'];
            if(joint.position.length() === 0) { data.active = false; return; }

            const worldPos = new THREE.Vector3();
            joint.getWorldPosition(worldPos);
            
            // è½¬ä¸ºèˆå°å±€éƒ¨åæ ‡
            const localPos = worldPos.clone().sub(stage.position);
            
            data.active = true;
            data.pos.copy(localPos);
            
            // è®¡ç®—é€Ÿåº¦
            if(data.lastPos.lengthSq() > 0) {
                data.vel.copy(data.pos).sub(data.lastPos);
            }
            data.lastPos.copy(data.pos);
        } else {
            data.active = false;
        }
    }

    function getGesture(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist'] || !hand.joints['middle-finger-tip']) return 'neutral';
        const d = hand.joints['wrist'].position.distanceTo(hand.joints['middle-finger-tip'].position);
        if (d < 0.08) return 'fist';
        if (d > 0.12) return 'palm';
        return 'neutral';
    }

    function render() {
        // æ›´æ–°æ‰‹éƒ¨æ•°æ®
        updateHand(hand1, handsData[0]);
        updateHand(hand2, handsData[1]);

        // æ‰‹åŠ¿åˆ¤æ–­
        let gesture = 'neutral';
        const g1 = getGesture(hand1); const g2 = getGesture(hand2);
        if(g1 !== 'neutral') gesture = g1; else if(g2 !== 'neutral') gesture = g2;

        // ç‰©ç†å‚æ•°
        const returnForce = 0.02;
        const friction = 0.90;
        const pushRadiusSq = 0.15 * 0.15; // 15cm

        // ç²’å­å¾ªç¯
        const pos = particleGeo.attributes.position.array;
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i*3;
            let px = pos[ix], py = pos[ix+1], pz = pos[ix+2];
            let vx = velocity[ix], vy = velocity[ix+1], vz = velocity[ix+2];

            // 1. æ‰‹éƒ¨æ‹¨åŠ¨ (æµä½“æ„Ÿ)
            for(let h=0; h<2; h++) {
                if(handsData[h].active) {
                    const dx = px - handsData[h].pos.x;
                    const dy = py - handsData[h].pos.y;
                    const dz = pz - handsData[h].pos.z;
                    const dSq = dx*dx + dy*dy + dz*dz;

                    if(dSq < pushRadiusSq) {
                        const d = Math.sqrt(dSq);
                        const f = (1 - d/0.15); // åŠ›åº¦

                        // æ’æ–¥
                        vx += (dx/d) * f * 0.003;
                        vy += (dy/d) * f * 0.003;
                        vz += (dz/d) * f * 0.003;

                        // æ‹–æ‹½ (è·Ÿéšæ‰‹é€Ÿ)
                        vx += handsData[h].vel.x * f * 0.05;
                        vy += handsData[h].vel.y * f * 0.05;
                        vz += handsData[h].vel.z * f * 0.05;
                    }
                }
            }

            // 2. æ‰‹åŠ¿å…¨å±€åŠ›
            if(gesture === 'fist') {
                vx -= px * 0.02; vy -= py * 0.02; vz -= pz * 0.02; // å¸å…¥
            } else if(gesture === 'palm') {
                vx += px * 0.01; vy += py * 0.01; vz += pz * 0.01; // ç‚¸å¼€
            } else {
                // å›å®¶
                vx += (posOriginal[ix] - px) * returnForce;
                vy += (posOriginal[ix+1] - py) * returnForce;
                vz += (posOriginal[ix+2] - pz) * returnForce;
            }

            // 3. ç‰©ç†ç§¯åˆ†
            vx *= friction; vy *= friction; vz *= friction;
            px += vx; py += vy; pz += vz;

            // å›å†™
            pos[ix] = px; pos[ix+1] = py; pos[ix+2] = pz;
            velocity[ix] = vx; velocity[ix+1] = vy; velocity[ix+2] = vz;
        }

        particleGeo.attributes.position.needsUpdate = true;
        
        // å˜è‰²é€»è¾‘
        if(gesture === 'palm') particles.material.color.lerp(new THREE.Color(0xffaa00), 0.1);
        else if(gesture === 'fist') particles.material.color.lerp(new THREE.Color(0xff0000), 0.1);
        else particles.material.color.lerp(new THREE.Color(0xffffff), 0.1);

        // è®©çº¢æ¡†è‡ªè½¬ï¼Œç¡®è®¤æ¸²æŸ“æ²¡æ­»
        if(stage.children[0]) stage.children[0].rotation.y += 0.01;

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
