<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Vegeta Scouter CN</title>
    <!-- 1. å¼•å…¥é¾™ç é£æ ¼çš„ä¸­æ–‡å­—ä½“ (ç«™é…·åº†ç§‘é»„æ²¹ä½“) -->
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+QingKe+HuangYou&display=swap" rel="stylesheet">
    
    <style>
        /* å…¨å±€åº”ç”¨è¯¥å­—ä½“ */
        body { margin: 0; background: #000; overflow: hidden; font-family: 'ZCOOL QingKe HuangYou', sans-serif; }
        
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 0, 0, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 999; color: #ffaa00;
        }

        button {
            padding: 15px 50px; font-size: 28px; 
            color: #000; background: #ffaa00; border: none; 
            border-radius: 4px; cursor: pointer; margin-top: 30px;
            box-shadow: 0 0 20px #ffaa00; 
            font-family: 'ZCOOL QingKe HuangYou', cursive; letter-spacing: 2px;
        }

        #hud-status {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            color: #ffaa00; font-size: 24px; pointer-events: none; 
            text-shadow: 0 0 5px #ff0000; display: none; letter-spacing: 2px;
        }

        /* éšè—å…ƒç´ ï¼Œç”¨äºå¼ºåˆ¶æµè§ˆå™¨é¢„åŠ è½½å­—ä½“ï¼Œé˜²æ­¢Canvasæ¸²æŸ“æ—¶å­—ä½“è¿˜æ²¡å¥½ */
        .font-preload { opacity: 0; position: absolute; font-family: 'ZCOOL QingKe HuangYou', cursive; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<!-- å­—ä½“é¢„åŠ è½½è§¦å‘ç‚¹ -->
<div class="font-preload">æˆ˜æ–—åŠ›æ¢æµ‹ä»ªæåº¦å±é™©è­¦æƒ•ä¸€èˆ¬èˆ¬</div>

<div id="launcher">
    <h1 style="text-shadow: 0 0 15px #ff0000; font-size: 50px; margin: 0;">èµ›äºšäººæˆ˜æ–—åŠ›æ¢æµ‹å™¨</h1>
    <p style="color: #fff; opacity: 0.8; font-size: 20px;">ç›®æ ‡è®¾å®šï¼šè´å‰å¡”</p>
    <div style="border:1px solid #ff4400; padding:20px; background:rgba(20,0,0,0.8); margin-top:20px; font-size: 22px;">
        <p>ğŸ‘‰ <b>å³æ‰‹æŒ‡å‘</b>ï¼šæ‰«æç›®æ ‡</p>
        <p>âœŠ <b>å·¦æ‰‹æ¡æ‹³</b>ï¼šé‡ç½®ç³»ç»Ÿ</p>
    </div>
    <button id="btn-start">å¯åŠ¨ç³»ç»Ÿ</button>
</div>

<div id="hud-status">ç³»ç»Ÿå°±ç»ª</div>

<script type="module">
    import * as THREE from 'three';
    import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

    let camera, scene, renderer;
    let handLeft, handRight;
    
    // è§†è§‰å¯¹è±¡
    let aimCursor;      // ç„å‡†ç”¨çš„åå­—
    let targetGroup;    // é”å®šåçš„ç‰¹æ•ˆç»„ (æ¡†+æŒ‡é’ˆ)
    let powerSprite;    // æˆ˜æ–—åŠ›UI
    let laserPlane;     // ä¸Šä¸‹æ‰«æçš„å…‰
    
    // é€»è¾‘æ§åˆ¶
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let isLocked = false;
    let scanInterval = null;

    // UI é…è‰²
    const THEME_COLOR = "#ffaa00"; // ç¥ç€æ©™
    const THEME_BG = "rgba(20, 0, 0, 0.85)"; // æ·±çº¢é»‘
    
    // Canvas åˆå§‹åŒ–
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 256;

    document.getElementById('btn-start').addEventListener('click', initAR);

    async function initAR() {
        if (!navigator.xr) return alert("WebXRä¸æ”¯æŒ");
        const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['local', 'hit-test'],
            optionalFeatures: ['hand-tracking', 'dom-overlay'],
            domOverlay: { root: document.body }
        });
        document.getElementById('launcher').style.display = 'none';
        document.getElementById('hud-status').style.display = 'block';
        initScene(session);
    }

    function initScene(session) {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);
        session.addEventListener('end', () => location.reload());

        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(0, 5, 2);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // 1. åå­—ç„å‡†å…‰æ ‡ (Sprite)
        const cursorTexture = createCursorTexture();
        const cursorMat = new THREE.SpriteMaterial({ map: cursorTexture, color: 0xffffff, transparent: true, opacity: 0.9 });
        aimCursor = new THREE.Sprite(cursorMat);
        aimCursor.scale.set(0.08, 0.08, 1);
        aimCursor.visible = false;
        scene.add(aimCursor);

        // 2. é”å®šç‰¹æ•ˆç»„
        createTargetVisuals();

        // 3. æ‰‹åŠ¿
        setupHands();

        renderer.setAnimationLoop(render);
    }

    // ç»˜åˆ¶åå­—è´´å›¾
    function createCursorTexture() {
        const cvs = document.createElement('canvas');
        cvs.width = 128; cvs.height = 128;
        const c = cvs.getContext('2d');
        c.strokeStyle = '#ffffff';
        c.lineWidth = 6;
        // åå­—
        c.beginPath(); c.moveTo(64, 20); c.lineTo(64, 108); c.stroke();
        c.beginPath(); c.moveTo(20, 64); c.lineTo(108, 64); c.stroke();
        // åœ†åœˆ
        c.beginPath(); c.arc(64, 64, 40, 0, Math.PI*2); c.stroke();
        return new THREE.CanvasTexture(cvs);
    }

    function createTargetVisuals() {
        targetGroup = new THREE.Group();
        targetGroup.visible = false;
        scene.add(targetGroup);

        // A. æˆ˜æœ¯æ¡† (Lå‹è§’è½)
        const bracketGeo = new THREE.BufferGeometry();
        const s = 0.3; 
        const vertices = new Float32Array([
            -s, s, 0,  -s+0.1, s, 0,  -s, s, 0,  -s, s-0.1, 0, // å·¦ä¸Š
             s, s, 0,   s-0.1, s, 0,   s, s, 0,   s, s-0.1, 0, // å³ä¸Š
            -s, -s, 0, -s+0.1, -s, 0, -s, -s, 0, -s, -s+0.1, 0, // å·¦ä¸‹
             s, -s, 0,  s-0.1, -s, 0,  s, -s, 0,  s, -s+0.1, 0  // å³ä¸‹
        ]);
        bracketGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        const bracketMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
        const brackets = new THREE.LineSegments(bracketGeo, bracketMat);
        targetGroup.add(brackets);

        // B. æ‰«ææ¿€å…‰
        const planeGeo = new THREE.PlaneGeometry(0.6, 0.02);
        const planeMat = new THREE.MeshBasicMaterial({ color: 0xff3300, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
        laserPlane = new THREE.Mesh(planeGeo, planeMat);
        targetGroup.add(laserPlane);

        // C. çº¯ç™½æŒ‡é’ˆ (å·¦å³)
        const ptrGeo = new THREE.ConeGeometry(0.05, 0.15, 4);
        const ptrMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
        const leftPtr = new THREE.Mesh(ptrGeo, ptrMat);
        leftPtr.position.set(-0.5, 0, 0); leftPtr.rotation.z = -Math.PI / 2; leftPtr.name = "leftPtr";
        targetGroup.add(leftPtr);

        const rightPtr = new THREE.Mesh(ptrGeo, ptrMat);
        rightPtr.position.set(0.5, 0, 0); rightPtr.rotation.z = Math.PI / 2; rightPtr.name = "rightPtr";
        targetGroup.add(rightPtr);
    }

    function setupHands() {
        const handModelFactory = new XRHandModelFactory();
        function buildHand(idx) {
            const hand = renderer.xr.getHand(idx);
            hand.add(handModelFactory.createHandModel(hand, "mesh"));
            hand.addEventListener('connected', () => {
                hand.traverse(child => {
                    if(child.isMesh) {
                        child.material = new THREE.MeshBasicMaterial({
                            color: 0xff5500, wireframe: true, transparent: true, opacity: 0.3
                        });
                    }
                });
            });
            scene.add(hand);
            return hand;
        }
        handLeft = buildHand(0);
        handRight = buildHand(1);
    }

    // --- ä¸­æ–‡ UI ç»˜åˆ¶æ ¸å¿ƒé€»è¾‘ ---
    function updateCanvasUI(powerValue, isFinal) {
        // æ¸…é™¤ç”»å¸ƒ
        ctx.clearRect(0, 0, 512, 256);

        // 1. èƒŒæ™¯ (åˆ‡è§’è®¾è®¡)
        ctx.fillStyle = THEME_BG;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(480, 0); ctx.lineTo(512, 32); 
        ctx.lineTo(512, 256); ctx.lineTo(32, 256); ctx.lineTo(0, 224); 
        ctx.closePath();
        ctx.fill();

        // 2. è¾¹æ¡†é¢œè‰²é€»è¾‘
        let borderColor = "#ffaa00"; // é»˜è®¤æ©™
        let dangerText = "æ­£åœ¨åˆ†æ...";
        
        // åªæœ‰å‡ºç»“æœæ—¶æ‰åˆ¤å®šç­‰çº§
        if (isFinal) {
            if (powerValue < 9000) {
                borderColor = "#ffffff"; // ç™½è‰²
                dangerText = "ä¸€èˆ¬èˆ¬";
            } else if (powerValue >= 9000 && powerValue <= 18000) {
                borderColor = "#ffaa00"; // æ©™è‰²
                dangerText = "è­¦æƒ•ï¼";
            } else {
                borderColor = "#ff0000"; // çº¢è‰²
                dangerText = "æåº¦å±é™©";
            }
        }

        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 6;
        ctx.stroke();

        // 3. è£…é¥°çº¿
        ctx.strokeStyle = "rgba(255, 100, 0, 0.3)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(20, 60); ctx.lineTo(492, 60); ctx.stroke();
        
        // 4. æ•°å€¼ç»˜åˆ¶
        ctx.font = "110px 'ZCOOL QingKe HuangYou'"; // ä½¿ç”¨é¾™ç é£æ ¼å­—ä½“
        ctx.textAlign = "center";
        ctx.shadowBlur = 15;
        ctx.shadowColor = borderColor;
        ctx.fillStyle = isFinal ? "#fff" : THEME_COLOR;
        ctx.fillText(powerValue, 256, 170);

        // 5. å·¦ä¸Šè§’æ ‡é¢˜: æˆ˜æ–—åŠ›æ¢æµ‹ä»ª
        ctx.font = "32px 'ZCOOL QingKe HuangYou'";
        ctx.fillStyle = "#ffaa00";
        ctx.shadowBlur = 0;
        ctx.textAlign = "left";
        ctx.fillText("æˆ˜æ–—åŠ›æ¢æµ‹ä»ª", 25, 45);

        // 6. å³ä¸Šè§’: å±é™©ç­‰çº§ (åŠ¨æ€å˜åŒ–)
        ctx.textAlign = "right";
        ctx.fillStyle = borderColor; // è·Ÿéšå±é™©ç­‰çº§å˜è‰²
        ctx.fillText(dangerText, 485, 45);

        // 7. åº•éƒ¨çŠ¶æ€ (ä¿ç•™åŸé€»è¾‘ä½†æ±‰åŒ–)
        ctx.textAlign = "center";
        ctx.fillStyle = "#ffffff";
        ctx.font = "28px 'ZCOOL QingKe HuangYou'";
        const statusText = isFinal ? "ç›®æ ‡å·²é”å®š" : "æ­£åœ¨è¯»å–æ•°æ®...";
        ctx.fillText(statusText, 256, 225);
    }

    // --- äº¤äº’é€»è¾‘ ---
    function triggerScan(position) {
        if (isLocked) return;
        isLocked = true;
        aimCursor.visible = false;

        // æˆ˜æœ¯æ¡†ä½ç½®
        targetGroup.position.copy(position);
        targetGroup.lookAt(camera.position); 
        targetGroup.visible = true;

        // UI ä½ç½® (è´å‰å¡”å¤´é¡¶)
        const uiPos = position.clone().add(new THREE.Vector3(0, 0.65, 0));

        if (powerSprite) scene.remove(powerSprite);
        const texture = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        powerSprite = new THREE.Sprite(mat);
        powerSprite.scale.set(1.0, 0.5, 1);
        powerSprite.position.copy(uiPos);
        scene.add(powerSprite);

        // åŠ¨ç”»æµç¨‹
        let steps = 0;
        // è®¾å®šè´å‰å¡”æˆ˜æ–—åŠ›: 18000 ~ 24000
        const targetVal = 18000 + Math.floor(Math.random() * 6000); 

        scanInterval = setInterval(() => {
            steps++;
            // éšæœºè·³åŠ¨
            const rnd = Math.floor(Math.random() * 25000);
            updateCanvasUI(rnd, false);
            texture.needsUpdate = true;

            // æ¿€å…‰åŠ¨ç”»
            if (targetGroup.visible) {
                laserPlane.position.y = Math.sin(steps * 0.5) * 0.25;
            }

            if (steps > 40) { // 2ç§’
                clearInterval(scanInterval);
                updateCanvasUI(targetVal, true);
                texture.needsUpdate = true;
                
                // æˆ˜æœ¯æ¡†å˜è‰²
                if (targetVal > 18000) {
                    targetGroup.children[0].material.color.setHex(0xff0000); // æåº¦å±é™©å˜çº¢
                } else if (targetVal > 9000) {
                    targetGroup.children[0].material.color.setHex(0xffaa00);
                }
            }
        }, 50);
    }

    function resetSystem() {
        isLocked = false;
        clearInterval(scanInterval);
        targetGroup.visible = false;
        targetGroup.children[0].material.color.setHex(0xffffff); // æ¢å¤ç™½è‰²
        if (powerSprite) {
            scene.remove(powerSprite);
            powerSprite = null;
        }
        document.getElementById('hud-status').innerText = "ç­‰å¾…æŒ‡ä»¤...";
    }

    // --- å§¿åŠ¿åˆ¤å®š ---
    function isPointing(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;
        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        const middleTip = hand.joints['middle-finger-tip'].position;
        // é£ŸæŒ‡è¿œï¼Œä¸­æŒ‡è¿‘
        return wrist.distanceTo(indexTip) > 0.10 && wrist.distanceTo(middleTip) < 0.10;
    }

    function isFist(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;
        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        return wrist.distanceTo(indexTip) < 0.09;
    }

    // --- æ¸²æŸ“å¾ªç¯ ---
    function render(timestamp, frame) {
        if (frame) {
            const refSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();

            if (!hitTestSourceRequested) {
                session.requestReferenceSpace('viewer').then(ref => {
                    session.requestHitTestSource({ space: ref }).then(source => hitTestSource = source);
                });
                hitTestSourceRequested = true;
            }

            if (hitTestSource && !isLocked) {
                const hits = frame.getHitTestResults(hitTestSource);
                if (hits.length > 0) {
                    const pose = hits[0].getPose(refSpace);
                    aimCursor.visible = true;
                    aimCursor.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                } else {
                    aimCursor.visible = false;
                }
            }

            if (!isLocked && aimCursor.visible && isPointing(handRight)) {
                triggerScan(aimCursor.position);
            }
            if (isLocked && isFist(handLeft)) {
                resetSystem();
            }

            // å¾…æœºåŠ¨ç”»ï¼šæŒ‡é’ˆæµ®åŠ¨
            if (isLocked && targetGroup.visible) {
                const t = timestamp / 500;
                const left = targetGroup.getObjectByName("leftPtr");
                const right = targetGroup.getObjectByName("rightPtr");
                if(left && right) {
                    const offset = 0.5 + Math.sin(t) * 0.05;
                    left.position.x = -offset;
                    right.position.x = offset;
                }
            }
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
