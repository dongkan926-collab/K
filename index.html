<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galaxy XR 螺旋丸</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        #info {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #00ffff; font-family: "Courier New", monospace; font-weight: bold;
            pointer-events: none; z-index: 10; text-shadow: 0 0 8px #00ffff;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="info">等待 AR 会话... <br> 左手控制: 握拳(消散) | 爪子(大玉螺旋丸) | 张开(压缩)</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let container;
        let camera, scene, renderer;
        
        // 粒子系统
        let particleSystem;
        const PARTICLE_COUNT = 4000; // 增加粒子数量，螺旋丸更密集
        
        // 交互状态
        const STATE = {
            DISSIPATE: 0,  // 握拳: 自由消散
            BIG_BALL: 1,   // 爪子: 大螺旋丸
            SMALL_BALL: 2  // 张开: 高密度小球
        };
        let currentState = STATE.DISSIPATE;
        let targetCenter = new THREE.Vector3(0, 0, -1);
        let targetRadius = 0.5;
        let isGathering = false;
        
        // 手部可视化
        let handVisualGroup;
        const jointsMesh = [];
        const bonesLines = [];
        const JOINT_COUNT = 25;
        
        const boneConnections = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20]
        ];

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local'); 
            container.appendChild(renderer.domElement);

            const sessionInit = { 
                requiredFeatures: ['hand-tracking'], 
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body } 
            };
            document.body.appendChild(ARButton.createButton(renderer, sessionInit));

            // 灯光
            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(0, 2, 0);
            scene.add(light);

            initParticles();
            initHandVisuals();

            window.addEventListener('resize', onWindowResize);
        }

        function initHandVisuals() {
            handVisualGroup = new THREE.Group();
            scene.add(handVisualGroup);

            // 关节: 稍微小一点，青色
            const jointGeo = new THREE.IcosahedronGeometry(0.005, 1);
            const jointMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });

            for(let i=0; i<JOINT_COUNT; i++) {
                const mesh = new THREE.Mesh(jointGeo, jointMat);
                mesh.visible = false;
                jointsMesh.push(mesh);
                handVisualGroup.add(mesh);
            }

            // 连线: 科技蓝
            const lineMat = new THREE.LineBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.4 });
            
            boneConnections.forEach(pair => {
                const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
                const line = new THREE.Line(geometry, lineMat);
                line.userData = { start: pair[0], end: pair[1] };
                line.visible = false;
                bonesLines.push(line);
                handVisualGroup.add(line);
            });
        }

        function initParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const x = (Math.random() - 0.5) * 2;
                const y = (Math.random() - 0.5) * 2 + 1.5;
                const z = (Math.random() - 0.5) * 2 - 1;
                positions.push(x, y, z);

                // --- 修改点：颜色改为螺旋丸风格 (青/蓝/白) ---
                const rand = Math.random();
                if (rand > 0.8) {
                    color.setHex(0xffffff); // 核心亮白
                } else if (rand > 0.4) {
                    color.setHex(0x00ffff); // 主要青色
                } else {
                    color.setHex(0x0066ff); // 深蓝边缘
                }
                
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // 纹理
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(200,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(0,255,255,0.3)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.PointsMaterial({
                size: 0.012,
                vertexColors: true,
                map: texture,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending, // 叠加模式，越聚越亮
                depthWrite: false
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (!frame) return;

            const session = renderer.xr.getSession();
            const referenceSpace = renderer.xr.getReferenceSpace();
            
            let leftHandFound = false;
            let leftHandJointsData = null;

            if (session.inputSources) {
                for (const inputSource of session.inputSources) {
                    if (inputSource.handedness === 'left' && inputSource.hand) {
                        leftHandFound = true;
                        leftHandJointsData = updateHandVisuals(inputSource.hand, frame, referenceSpace);
                        
                        if (leftHandJointsData) {
                            analyzeGesture(leftHandJointsData);
                        }
                    }
                }
            }

            if (!leftHandFound) {
                currentState = STATE.DISSIPATE;
                isGathering = false;
                handVisualGroup.visible = false;
            } else {
                handVisualGroup.visible = true;
            }

            updateParticles();
            updateInfoUI();

            renderer.render(scene, camera);
        }

        function updateHandVisuals(hand, frame, refSpace) {
            const jointData = {};
            let wristPos = null;

            for (let i = 0; i < JOINT_COUNT; i++) {
                const jointName = getJointNameByIndex(i);
                if(!jointName) continue;
                const joint = hand.get(jointName);
                const pose = frame.getJointPose(joint, refSpace);

                if (pose) {
                    jointsMesh[i].position.copy(pose.transform.position);
                    jointsMesh[i].visible = true;
                    jointData[i] = new THREE.Vector3().copy(pose.transform.position);
                } else {
                    jointsMesh[i].visible = false;
                }
            }

            bonesLines.forEach(line => {
                const startIdx = line.userData.start;
                const endIdx = line.userData.end;
                if (jointsMesh[startIdx].visible && jointsMesh[endIdx].visible) {
                    const posAttr = line.geometry.attributes.position;
                    const p1 = jointsMesh[startIdx].position;
                    const p2 = jointsMesh[endIdx].position;
                    posAttr.setXYZ(0, p1.x, p1.y, p1.z);
                    posAttr.setXYZ(1, p2.x, p2.y, p2.z);
                    posAttr.needsUpdate = true;
                    line.visible = true;
                } else {
                    line.visible = false;
                }
            });

            return Object.keys(jointData).length > 0 ? jointData : null;
        }

        function analyzeGesture(joints) {
            const wrist = joints[0];
            const middleMcp = joints[9];
            
            if (!wrist || !middleMcp) return;

            // --- 修改点：位置调整 ---
            const palmCenter = new THREE.Vector3().copy(wrist).add(middleMcp).multiplyScalar(0.5);
            // 向上偏移量改为 0.12 (12cm)，离手心更远，悬浮感更好
            targetCenter.copy(palmCenter).add(new THREE.Vector3(0, 0.12, 0));

            // 手势判断逻辑
            const tips = [8, 12, 16, 20];
            let totalDist = 0;
            tips.forEach(idx => {
                if(joints[idx]) totalDist += joints[idx].distanceTo(wrist);
            });
            const avgDist = totalDist / 4;

            if (avgDist < 0.08) {
                currentState = STATE.DISSIPATE; // 握拳
                isGathering = false;
            } else if (avgDist > 0.14) {
                currentState = STATE.SMALL_BALL; // 张开
                targetRadius = 0.05; // 压缩态
                isGathering = true;
            } else {
                currentState = STATE.BIG_BALL; // 爪子
                targetRadius = 0.14; // 大玉螺旋丸
                isGathering = true;
            }
        }

        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            
            // --- 修改点：极速旋转参数 ---
            // 时间系数 * 5.0，让球体疯狂旋转
            const time = performance.now() * 0.006; 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let currentPos = new THREE.Vector3(positions[i3], positions[i3+1], positions[i3+2]);
                
                if (isGathering) {
                    // === 聚集模式 (螺旋丸) ===
                    
                    // 1. 计算目标位置 (Fibonacci Sphere)
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    
                    // 增加一些随机偏移，让球体表面看起来有厚度和湍流
                    const rVariation = targetRadius * (0.9 + Math.random() * 0.2); 

                    // 基础球体位置
                    const tx = rVariation * Math.cos(theta) * Math.sin(phi);
                    const ty = rVariation * Math.sin(theta) * Math.sin(phi);
                    const tz = rVariation * Math.cos(phi);

                    // 2. 施加多轴旋转 (核心修改：转得更快，更乱)
                    // 绕 Y 轴高速旋转 + 绕 Z 轴缓慢进动
                    const rotX = tx * Math.cos(time) - tz * Math.sin(time);
                    const rotZ = tx * Math.sin(time) + tz * Math.cos(time);
                    
                    // 简单的湍流扰动
                    const turbulence = Math.sin(time * 5 + i) * 0.01;

                    const targetPos = new THREE.Vector3(rotX + turbulence, ty + turbulence, rotZ).add(targetCenter);
                    
                    // 3. 极速吸附 (Lerp factor 0.15 -> 0.2)
                    currentPos.lerp(targetPos, 0.2);

                } else {
                    // === 握拳消散模式 (核心修改) ===
                    
                    // 逻辑：给粒子一个背离中心的力，让它们炸开
                    
                    // 计算从中心指向粒子的向量
                    const direction = new THREE.Vector3().subVectors(currentPos, targetCenter).normalize();
                    if (direction.lengthSq() === 0) direction.set(0,1,0); // 防止除零
                    
                    // 施加斥力速度 (炸开的速度)
                    const explodeSpeed = 0.02 + Math.random() * 0.03;
                    currentPos.add(direction.multiplyScalar(explodeSpeed));
                    
                    // 加上随机扰动，模拟气流
                    currentPos.x += (Math.random() - 0.5) * 0.01;
                    currentPos.y += (Math.random() - 0.5) * 0.01;
                    currentPos.z += (Math.random() - 0.5) * 0.01;

                    // 重生逻辑：如果飞得太远（例如超过 1.0米），或者太久了，
                    // 为了不让屏幕空掉，我们让它在手附近缓慢重生
                    if (currentPos.distanceTo(targetCenter) > 0.8) {
                        // 重置到中心附近的一个随机云团里
                        currentPos.copy(targetCenter).add(new THREE.Vector3(
                            (Math.random()-0.5)*0.3,
                            (Math.random()-0.5)*0.3,
                            (Math.random()-0.5)*0.3
                        ));
                    }
                }

                positions[i3] = currentPos.x;
                positions[i3+1] = currentPos.y;
                positions[i3+2] = currentPos.z;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        function getJointNameByIndex(index) {
            const joints = [
                "wrist", 
                "thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip",
                "index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip",
                "middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip",
                "ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip",
                "pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"
            ];
            return joints[index];
        }

        function updateInfoUI() {
            const info = document.getElementById('info');
            let text = "";
            if (!renderer.xr.isPresenting) {
                text = "点击 START AR 启动螺旋丸";
            } else {
                if (currentState === STATE.DISSIPATE) text = "状态: 查克拉消散 (握拳)";
                else if (currentState === STATE.BIG_BALL) text = "状态: 大玉螺旋丸 (爪子)";
                else if (currentState === STATE.SMALL_BALL) text = "状态: 高密度压缩 (张开)";
            }
            info.innerHTML = text;
        }
    </script>
</body>
</html>
