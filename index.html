<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galaxy XR æ— é™ç«åŠ›ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: "Microsoft YaHei", sans-serif; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #2b0a0a 0%, #000 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 9999; color: #fff;
        }

        h1 { font-size: 2.0rem; color: #FFD700; text-shadow: 0 0 10px #D50000; letter-spacing: 2px; margin-bottom: 10px; }
        .subtitle { font-size: 1rem; color: #ccc; margin-bottom: 30px; opacity: 0.8; }

        #start-btn {
            padding: 15px 50px; font-size: 1.2rem; font-weight: bold;
            color: #fff; background: linear-gradient(to right, #D62828, #B71C1C);
            border: 2px solid #FFD700; border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 20px rgba(214, 40, 40, 0.4);
        }

        .guide-grid {
            margin-top: 30px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
            width: 90%; max-width: 400px;
        }
        .guide-card {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,215,0,0.2);
            padding: 10px; border-radius: 10px; text-align: center; font-size: 0.8rem;
        }
        .icon { font-size: 1.2rem; display: block; margin-bottom: 5px; }

        #ar-status {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #FFD700; font-weight: bold; font-size: 18px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); pointer-events: none;
            display: none; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>æ— é™Â·æ•£è´¢æµ</h1>
        <div class="subtitle">Galaxy XR å¢å¼ºç°å®ä½“éªŒ</div>
        <button id="start-btn" disabled>ç¯å¢ƒæ£€æµ‹ä¸­...</button>
        
        <div class="guide-grid">
            <div class="guide-card"><span class="icon">ğŸ–ï¸</span><b>æ‘Šæ‰‹</b><br>æŒå¿ƒèšèƒ½ (å¸é™„)</div>
            <div class="guide-card"><span class="icon">ğŸ‘‰</span><b>å‰‘æŒ‡</b><br>æ— é™è¿å°„ (èƒŒåç”Ÿæˆ)</div>
            <div class="guide-card"><span class="icon">âœŠ</span><b>æ¡æ‹³</b><br>å…¨å±é‡ç½® (å½’ä½)</div>
        </div>
    </div>

    <div id="ar-status">ç­‰å¾…æ‰‹åŠ¿...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let container, camera, scene, renderer;
        let hand;
        
        // æ ¸å¿ƒå˜é‡
        const BILLS = [];
        const BILL_COUNT = 50; 
        const TEXTS = []; 
        
        let currentMode = 'IDLE'; 
        let reticle; 
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        
        let lastTime = 0;
        let fireRateTimer = 0;

        // UI
        const btn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');
        const statusText = document.getElementById('ar-status');

        init();

        // --- 1. äººæ°‘å¸çº¹ç† (ä¿æŒé«˜æ¸…) ---
        function createRMBTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            const grd = ctx.createLinearGradient(0, 0, 512, 0);
            grd.addColorStop(0, '#E040FB'); 
            grd.addColorStop(0.2, '#D50000'); 
            grd.addColorStop(1, '#FF80AB'); 
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 512, 256);
            
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;
            ctx.strokeRect(10, 10, 492, 236);
            
            ctx.beginPath();
            ctx.arc(380, 128, 90, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fill();

            ctx.fillStyle = '#FFEB3B'; 
            ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 10;
            ctx.font = "900 110px Arial"; ctx.fillText("100", 40, 150);
            
            ctx.font = "bold 36px Microsoft YaHei"; ctx.shadowBlur = 2;
            ctx.fillText("ä¸­å›½äººæ°‘é“¶è¡Œ", 40, 50);

            ctx.beginPath(); ctx.fillStyle = '#FFD700';
            ctx.arc(460, 40, 20, 0, Math.PI*2); ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createTextTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = "bold 80px Arial";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillStyle = "#FFD700"; ctx.strokeStyle = "#D50000";
            ctx.lineWidth = 6; ctx.strokeText("+100", 128, 64); ctx.fillText("+100", 128, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 2.0));

            // å‡†æ˜Ÿ
            const reticleGeo = new THREE.RingGeometry(0.04, 0.05, 32);
            const reticleMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); 
            reticle = new THREE.Mesh(reticleGeo, reticleMat);
            reticle.rotation.x = -Math.PI / 2;
            reticle.visible = false;
            scene.add(reticle);

            // é’ç¥¨æ± 
            const billTex = createRMBTexture();
            const billGeo = new THREE.PlaneGeometry(0.155, 0.077);
            const billMat = new THREE.MeshStandardMaterial({ map: billTex, side: THREE.DoubleSide, roughness: 0.6 });

            for (let i = 0; i < BILL_COUNT; i++) {
                const mesh = new THREE.Mesh(billGeo, billMat);
                resetBillToIdle(mesh, i);
                scene.add(mesh);
                
                BILLS.push({
                    mesh: mesh,
                    state: 'IDLE', // IDLE, PALM_ORBIT, FINGER_GATHER, REAR_SPAWN, FLYING, DONE
                    velocity: new THREE.Vector3(),
                    targetPos: new THREE.Vector3(),
                    gatherOffset: new THREE.Vector3(),
                    idlePhase: Math.random() * Math.PI * 2
                });
            }

            hand = renderer.xr.getHand(0);
            scene.add(hand);

            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        btn.innerText = "å¯åŠ¨Â·æ— é™ç«åŠ›";
                        btn.disabled = false;
                        btn.onclick = onStartAR;
                    } else {
                        btn.innerText = "è®¾å¤‡ä¸æ”¯æŒ AR";
                    }
                });
            }
        }

        function resetBillToIdle(mesh, index) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 0.8 + Math.random() * 0.8; 
            const y = 1.0 + (Math.random() - 0.5) * 0.8; 
            mesh.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
            mesh.visible = true;
        }

        async function onStartAR() {
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['hit-test', 'hand-tracking']
            });
            renderer.xr.setReferenceSpaceType('local');
            renderer.xr.setSession(session);
            
            overlay.style.display = 'none';
            statusText.style.display = 'block';

            session.addEventListener('end', () => {
                overlay.style.display = 'flex';
                statusText.style.display = 'none';
                hitTestSource = null;
                hitTestSourceRequested = false;
            });
            
            animate();
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (renderer.xr.isPresenting) {
                handleHitTest(frame);
                handleGestures(dt);
                updateBills(dt, timestamp);
                updateEffects(dt);
            }
            renderer.render(scene, camera);
        }

        function handleHitTest(frame) {
            if (currentMode !== 'SWORD') {
                reticle.visible = false;
                return;
            }
            const session = renderer.xr.getSession();
            if (!hitTestSourceRequested) {
                session.requestReferenceSpace('viewer').then((refSpace) => {
                    session.requestHitTestSource({ space: refSpace }).then((source) => {
                        hitTestSource = source;
                    });
                });
                hitTestSourceRequested = true;
            }
            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const pose = hit.getPose(renderer.xr.getReferenceSpace());
                    reticle.visible = true;
                    reticle.position.copy(pose.transform.position);
                    reticle.rotation.y += 0.05;
                } else {
                    reticle.visible = false;
                }
            }
        }

        function handleGestures(dt) {
            const joints = hand.joints;
            if (!joints || !joints['wrist']) return;

            const wrist = joints['wrist'].position;
            const indexTip = joints['index-finger-tip'].position;
            const middleTip = joints['middle-finger-tip'].position;
            const thumbTip = joints['thumb-tip'].position;
            const pinkyTip = joints['pinky-finger-tip'].position;

            const dIndexMiddle = indexTip.distanceTo(middleTip);
            const dIndexWrist = indexTip.distanceTo(wrist);
            const dPinkyWrist = pinkyTip.distanceTo(wrist);
            const dThumbIndex = thumbTip.distanceTo(indexTip);

            // --- çŠ¶æ€æœºåˆ‡æ¢ ---

            // 1. æ¡æ‹³ (FIST): é‡ç½®
            if (dIndexWrist < 0.10 && dPinkyWrist < 0.08) {
                if (currentMode !== 'IDLE') {
                    currentMode = 'IDLE';
                    statusText.innerText = "çŠ¶æ€ï¼šå…¨å±é‡ç½®";
                    // å¼ºåˆ¶æ‰€æœ‰é’ç¥¨å½’ä½
                    BILLS.forEach((b, i) => {
                        b.state = 'IDLE';
                        resetBillToIdle(b.mesh, i);
                    });
                }
            }
            // 2. å‰‘æŒ‡ (SWORD): æŒ‡å°–æ±‡èš + å°„å‡»
            else if (dIndexMiddle < 0.04 && dIndexWrist > 0.12 && dPinkyWrist < 0.08) {
                currentMode = 'SWORD';
                statusText.innerText = "çŠ¶æ€ï¼šæ— é™è¿å°„ (èƒŒåç”Ÿæˆ -> æŒ‡å°– -> å‘å°„)";

                // å°„å‡»è®¡æ—¶å™¨
                fireRateTimer += dt;
                // æ¯ 0.08 ç§’å‘å°„ä¸€å¼  (é«˜å°„é€Ÿ)
                if (fireRateTimer > 0.08) { 
                    fireRateTimer = 0;
                    fireOneBill(indexTip, wrist);
                }
            }
            // 3. æ‘Šæ‰‹ (PALM): æŒå¿ƒæ±‡èš
            else if (dIndexWrist > 0.10 && dPinkyWrist > 0.10 && dThumbIndex > 0.08) {
                currentMode = 'PALM';
                statusText.innerText = "çŠ¶æ€ï¼šæŒå¿ƒèšèƒ½ (å¸é™„)";
            }
        }

        function fireOneBill(fingerTipPos, wristPos) {
            // ç¡®å®šæ‰“å‡»ç›®æ ‡
            let target = new THREE.Vector3();
            if (reticle.visible) {
                target.copy(reticle.position);
            } else {
                // ç›²å°„ï¼šæ²¿æŒ‡å°–æ–¹å‘å»¶ä¼¸
                const aimDir = new THREE.Vector3().subVectors(fingerTipPos, wristPos).normalize();
                target.copy(fingerTipPos).add(aimDir.multiplyScalar(5.0));
            }

            // --- é€»è¾‘ï¼šå¯»æ‰¾å­å¼¹ ---
            // 1. ä¼˜å…ˆæ‰¾å·²ç»èšåœ¨æŒ‡å°–çš„ (FINGER_GATHER)
            let bill = BILLS.find(b => b.state === 'FINGER_GATHER');
            
            // 2. æ²¡æœ‰çš„è¯ï¼Œæ‰¾åœ¨åŠè·¯ä¸Šçš„ (REAR_SPAWN) - åˆšä»èƒŒåç”Ÿæˆè¿˜åœ¨é£å‘æŒ‡å°–çš„
            if (!bill) bill = BILLS.find(b => b.state === 'REAR_SPAWN');

            // 3. è¿˜æ²¡æœ‰ï¼Œæ‰¾é—²ç½®çš„ (IDLE æˆ– PALM_ORBIT)
            if (!bill) bill = BILLS.find(b => b.state === 'IDLE' || b.state === 'PALM_ORBIT');

            // 4. ã€æ— é™æµæ ¸å¿ƒã€‘å¦‚æœå…¨éƒ½æ²¡äº† (éƒ½æ‰“å‡ºå»äº†)ï¼Œå°±å›æ”¶ä¸€å¼ æ‰“å®Œçš„ (DONE)
            if (!bill) {
                bill = BILLS.find(b => b.state === 'DONE');
                if (bill) {
                    // è¿™é‡Œçš„ bill æ˜¯å›æ”¶å›æ¥çš„ï¼Œå…ˆç¬é—´ä¼ é€åˆ°èƒŒåï¼Œæ¨¡æ‹Ÿ"æ–°ç”Ÿæˆ"
                    // å‡è®¾ Camera åœ¨åŸç‚¹é™„è¿‘ï¼Œæˆ–è€…æˆ‘ä»¬ç›´æ¥ç”¨ head poseã€‚
                    // ç®€åŒ–ç‰ˆï¼šä¼ é€åˆ°æŒ‡å°–åæ–¹ 0.5ç±³å¤„
                    const backOffset = new THREE.Vector3().subVectors(wristPos, fingerTipPos).normalize().multiplyScalar(0.8);
                    bill.mesh.position.copy(wristPos).add(backOffset);
                    bill.mesh.visible = true;
                    // æ ‡è®°ä¸º REAR_SPAWN çŠ¶æ€ï¼Œè®© updateBills å¤„ç†å®ƒé£å‘æŒ‡å°–çš„è¿‡ç¨‹
                    // ä½†ä¸ºäº†å°„å‡»æµç•…ï¼Œè¿™é‡Œç›´æ¥å‘å°„
                }
            }

            // å‘å°„ï¼
            if (bill) {
                bill.state = 'FLYING';
                bill.mesh.visible = true;
                bill.targetPos.copy(target);
                // å¼ºåˆ¶å¯¹å‡†ç›®æ ‡
                bill.mesh.lookAt(target);
                bill.mesh.rotateX(-Math.PI/2);
            }
        }

        function spawnPlus100(pos) {
            const tex = createTextTexture();
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.position.copy(pos);
            sprite.position.y += 0.2;
            sprite.scale.set(0.4, 0.2, 1);
            scene.add(sprite);
            TEXTS.push({ sprite: sprite, life: 0.8 });
        }

        function updateBills(dt, t_ms) {
            const t = t_ms * 0.001;
            const joints = hand.joints;

            let palmCenter = new THREE.Vector3();
            let fingerTip = new THREE.Vector3();
            let rearSpawnPoint = new THREE.Vector3(); // èƒŒåç”Ÿæˆç‚¹

            if (joints && joints['wrist']) {
                const wrist = joints['wrist'].position;
                palmCenter.copy(wrist).add(new THREE.Vector3(0, 0.1, 0));
                fingerTip.copy(joints['index-finger-tip'].position);
                
                // è®¡ç®—èƒŒåç”Ÿæˆç‚¹ï¼šæ‰‹è…•åæ–¹ 1ç±³ï¼Œä¸Šæ–¹ 0.5ç±³
                // è¿™æ ·çœ‹èµ·æ¥é’±æ˜¯ä»ä½ è‚©è†€/è„‘åé£è¿‡æ¥çš„
                rearSpawnPoint.copy(wrist).add(new THREE.Vector3(0, 0.5, 0.5)); 
            }

            BILLS.forEach((b, i) => {
                if (!b.mesh.visible) return;

                // --- çŠ¶æ€æ£€æµ‹ä¸è‡ªåŠ¨æµè½¬ ---
                
                // A. å¦‚æœè¿›å…¥ SWORD æ¨¡å¼ï¼Œå¼ºè¡ŒæŠŠ IDLE å’Œ PALM çš„é’±å¸åˆ°æŒ‡å°–
                if (currentMode === 'SWORD') {
                    if (b.state === 'IDLE' || b.state === 'PALM_ORBIT') {
                        b.state = 'FINGER_GATHER';
                        // éšæœºåˆ†å¸ƒåœ¨æŒ‡å°–å‘¨å›´
                        b.gatherOffset.set((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2);
                    }
                    // å¦‚æœé’±æ‰“å…‰äº†ï¼Œè‡ªåŠ¨è¿›å…¥"èƒŒåç”Ÿæˆ"æ¨¡å¼ (REAR_SPAWN)
                    // é€»è¾‘ï¼šå¦‚æœå¤„äº DONE çŠ¶æ€çš„é’±å¤ªå¤šï¼Œå°±æ‹¿å‡ºæ¥å¤ç”¨
                    if (b.state === 'DONE') {
                         // è¿™é‡Œçš„å¤ç”¨é€»è¾‘åœ¨ fireOneBill é‡Œå¤„ç†æ›´ç›´æ¥ï¼Œè¿™é‡Œä¸»è¦å¤„ç†åŠ¨ç”»
                    }
                }

                // B. å¦‚æœè¿›å…¥ PALM æ¨¡å¼ï¼Œå¸åˆ°æ‰‹æŒ
                if (currentMode === 'PALM' && (b.state === 'IDLE' || b.state === 'FINGER_GATHER')) {
                    b.state = 'PALM_ORBIT';
                }

                // C. å¦‚æœæ¾æ‰‹ (IDLE)ï¼Œæ‰€æœ‰æœªå‘å°„çš„é’±å½’ä½
                if (currentMode === 'IDLE' && (b.state === 'FINGER_GATHER' || b.state === 'PALM_ORBIT' || b.state === 'REAR_SPAWN')) {
                    b.state = 'IDLE';
                }


                // --- ç‰©ç†è¡Œä¸ºæ›´æ–° ---

                // 1. å¾…æœº (IDLE) - ç»•èº«ä½“è½¬
                if (b.state === 'IDLE') {
                    const angle = t * 0.5 + b.idlePhase;
                    const r = 1.2; 
                    const target = new THREE.Vector3(Math.cos(angle)*r, b.mesh.position.y, Math.sin(angle)*r);
                    target.y += Math.sin(t+i)*0.002;
                    b.mesh.position.lerp(target, 0.05);
                    b.mesh.rotation.y += dt;
                }

                // 2. æŒå¿ƒèšèƒ½ (PALM_ORBIT) - ç»•æ‰‹æŒç‹‚è½¬
                else if (b.state === 'PALM_ORBIT') {
                    const angle = t * 5.0 + i * 0.5; // æé€Ÿæ—‹è½¬
                    const r = 0.25; 
                    const target = new THREE.Vector3().copy(palmCenter);
                    target.x += Math.cos(angle) * r;
                    target.z += Math.sin(angle) * r;
                    // èºæ—‹ä¸Šå‡ä¸‹é™
                    target.y += Math.sin(angle*3)*0.15;
                    
                    b.mesh.position.lerp(target, 0.15);
                    b.mesh.rotateZ(10*dt); // è‡ªèº«ä¹Ÿè½¬
                }

                // 3. æŒ‡å°–æ±‡èš (FINGER_GATHER) - è“„åŠ›
                else if (b.state === 'FINGER_GATHER') {
                    const target = new THREE.Vector3().copy(fingerTip).add(b.gatherOffset);
                    b.mesh.position.lerp(target, 0.2); // å¿«é€Ÿå¸é™„
                    b.mesh.lookAt(target); // è½¦å¤´æœå‘åœ†å¿ƒ
                    b.mesh.rotateZ(10 * dt);
                }

                // 4. èƒŒåç”Ÿæˆé£è¡Œä¸­ (REAR_SPAWN) - è§†è§‰è¿‡æ¸¡
                // è¿™æ˜¯ç»™"æ— é™æµ"ç”¨çš„ï¼Œé’±ä»èƒŒåé£åˆ°æŒ‡å°–çš„è¿‡ç¨‹
                else if (b.state === 'REAR_SPAWN') {
                    // é£å‘æŒ‡å°–
                    const dist = b.mesh.position.distanceTo(fingerTip);
                    const dir = new THREE.Vector3().subVectors(fingerTip, b.mesh.position).normalize();
                    b.mesh.position.add(dir.multiplyScalar(5.0 * dt)); // é£å¾—å¾ˆå¿«
                    
                    if (dist < 0.1) {
                        b.state = 'FINGER_GATHER'; // åˆ°è¾¾æŒ‡å°–ï¼Œè¿›å…¥æ±‡èšçŠ¶æ€ç­‰å¾…å‘å°„
                    }
                }

                // 5. å°„å‡» (FLYING)
                else if (b.state === 'FLYING') {
                    const speed = 10.0; // å­å¼¹é€Ÿåº¦
                    const dir = new THREE.Vector3().subVectors(b.targetPos, b.mesh.position).normalize();
                    const dist = b.mesh.position.distanceTo(b.targetPos);
                    
                    b.mesh.position.add(dir.multiplyScalar(speed * dt));
                    b.mesh.rotateZ(20 * dt); // é£ç‰Œç‰¹æ•ˆ

                    if (dist < 0.3) {
                        b.state = 'DONE';
                        b.mesh.visible = false;
                        spawnPlus100(b.targetPos);
                    }
                }
            });
        }

        function updateEffects(dt) {
            for (let i = TEXTS.length - 1; i >= 0; i--) {
                const t = TEXTS[i];
                t.life -= dt;
                t.sprite.position.y += dt * 0.5;
                t.sprite.material.opacity = t.life;
                if (t.life <= 0) {
                    scene.remove(t.sprite);
                    TEXTS.splice(i, 1);
                }
            }
        }
    </script>
</body>
</html>
