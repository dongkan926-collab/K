<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XR æš´åŠ›æ–¹å—æµä½“</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #222;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 999;
        }
        button {
            padding: 20px 50px; font-size: 24px; border-radius: 10px; border: none;
            background: #ff00ff; color: #fff; font-weight: bold; cursor: pointer;
        }
        p { margin-top: 15px; color: #aaa; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<div id="launcher">
    <h1>ğŸŸ¥ æš´åŠ›æ–¹å—æµ‹è¯•</h1>
    <button id="btn-enter">å¯åŠ¨ AR</button>
    <p>å¦‚æœçœ‹åˆ°ä¸€å †å½©è‰²æ–¹å—ï¼Œè¯´æ˜æ¸²æŸ“æˆåŠŸ</p>
</div>

<script type="module">
    import * as THREE from 'three';

    let camera, scene, renderer;
    let hand1, hand2;
    let stage;
    let meshSystem;
    const dummy = new THREE.Object3D();

    // ç²’å­æ•°é‡ï¼š1000ä¸ªå¤§æ–¹å—
    const PARTICLE_COUNT = 1000;
    
    // ç‰©ç†æ•°æ®
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const vel = new Float32Array(PARTICLE_COUNT * 3);
    const originalPos = new Float32Array(PARTICLE_COUNT * 3);

    // æ‰‹éƒ¨æ•°æ®
    const handsData = [
        { pos: new THREE.Vector3(), vel: new THREE.Vector3(), lastPos: new THREE.Vector3(), active: false },
        { pos: new THREE.Vector3(), vel: new THREE.Vector3(), lastPos: new THREE.Vector3(), active: false }
    ];

    document.getElementById('btn-enter').addEventListener('click', async () => {
        if (!navigator.xr) return alert("ä¸æ”¯æŒ XR");
        try {
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local'],
                optionalFeatures: ['hand-tracking']
            });
            document.getElementById('launcher').style.display = 'none';
            initThree(session);
        } catch (e) {
            alert("å¯åŠ¨å¤±è´¥: " + e.message);
        }
    });

    function initThree(session) {
        scene = new THREE.Scene();
        scene.background = null;

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.05, 100);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);

        session.addEventListener('end', () => {
            renderer.setAnimationLoop(null);
            document.getElementById('launcher').style.display = 'flex';
        });

        // èˆå°ï¼šçœ¼å‰ 0.5 ç±³
        stage = new THREE.Group();
        stage.position.set(0, -0.2, -0.5);
        scene.add(stage);

        // 1. çº¢æ¡† (å‚ç…§ç‰©)
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.6, 0.6),
            new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
        );
        stage.add(box);

        // 2. åˆ›å»ºå®ä½“æ–¹å—ç²’å­
        createBlockParticles();

        // 3. æ‰‹éƒ¨
        hand1 = renderer.xr.getHand(0); scene.add(hand1);
        hand2 = renderer.xr.getHand(1); scene.add(hand2);

        renderer.setAnimationLoop(render);
    }

    function createBlockParticles() {
        // ä½¿ç”¨ç®€å•çš„ç«‹æ–¹ä½“ï¼Œå°ºå¯¸è®¾ä¸º 0.02 (2å˜ç±³)ï¼Œç¡®ä¿è‚‰çœ¼å¯è§
        const geometry = new THREE.BoxGeometry(0.02, 0.02, 0.02);
        
        // ã€å…³é”®ã€‘å®Œå…¨ä¸é€æ˜æè´¨ï¼Œé²œè‰³çš„é¢œè‰²
        const material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: false, // ä¸¥ç¦é€æ˜
            opacity: 1.0,
            depthTest: false,   // å¼ºåˆ¶åœ¨æœ€å‰
            depthWrite: false   
        });

        meshSystem = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);
        
        // åˆå§‹åŒ–
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const x = (Math.random()-0.5) * 0.4;
            const y = (Math.random()-0.5) * 0.4;
            const z = (Math.random()-0.5) * 0.4;

            pos[i*3] = x; pos[i*3+1] = y; pos[i*3+2] = z;
            originalPos[i*3] = x; originalPos[i*3+1] = y; originalPos[i*3+2] = z;
            vel[i*3] = 0; vel[i*3+1] = 0; vel[i*3+2] = 0;

            dummy.position.set(x,y,z);
            dummy.updateMatrix();
            meshSystem.setMatrixAt(i, dummy.matrix);
            
            // éšæœºé²œè‰³é¢œè‰²
            const color = new THREE.Color();
            color.setHSL(Math.random(), 1.0, 0.5);
            meshSystem.setColorAt(i, color);
        }
        
        stage.add(meshSystem);
    }

    function updateHand(hand, data) {
        if(hand?.joints?.['index-finger-tip']?.position?.length() > 0) {
            const worldPos = new THREE.Vector3();
            hand.joints['index-finger-tip'].getWorldPosition(worldPos);
            const localPos = worldPos.clone().sub(stage.position);
            
            data.active = true;
            data.pos.copy(localPos);
            if(data.lastPos.lengthSq() > 0) {
                data.vel.copy(data.pos).sub(data.lastPos).multiplyScalar(2.0);
            }
            data.lastPos.copy(data.pos);
        } else {
            data.active = false;
        }
    }

    function getGesture(hand) {
        if(!hand?.joints?.['wrist'] || !hand?.joints?.['middle-finger-tip']) return 'neutral';
        const d = hand.joints['wrist'].position.distanceTo(hand.joints['middle-finger-tip'].position);
        if(d < 0.08) return 'fist';
        if(d > 0.12) return 'palm';
        return 'neutral';
    }

    function render() {
        updateHand(hand1, handsData[0]);
        updateHand(hand2, handsData[1]);

        let gesture = 'neutral';
        const g1 = getGesture(hand1); const g2 = getGesture(hand2);
        if(g1 !== 'neutral') gesture = g1; else if(g2 !== 'neutral') gesture = g2;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i*3;
            let px = pos[ix], py = pos[ix+1], pz = pos[ix+2];
            let vx = vel[ix], vy = vel[ix+1], vz = vel[ix+2];

            // 1. æ‰‹éƒ¨æµä½“äº¤äº’
            for(let h=0; h<2; h++) {
                if(handsData[h].active) {
                    const dx = px - handsData[h].pos.x;
                    const dy = py - handsData[h].pos.y;
                    const dz = pz - handsData[h].pos.z;
                    const dSq = dx*dx + dy*dy + dz*dz;
                    
                    if(dSq < 0.04) { // 20cmèŒƒå›´
                        const d = Math.sqrt(dSq);
                        const f = (1 - d/0.2);
                        // æ¨å¼€
                        vx += (dx/d) * f * 0.005; 
                        vy += (dy/d) * f * 0.005;
                        vz += (dz/d) * f * 0.005;
                        // æ‹–æ‹½
                        vx += handsData[h].vel.x * f * 0.1;
                        vy += handsData[h].vel.y * f * 0.1;
                        vz += handsData[h].vel.z * f * 0.1;
                    }
                }
            }

            // 2. æ‰‹åŠ¿
            if(gesture === 'fist') {
                vx -= px * 0.05; vy -= py * 0.05; vz -= pz * 0.05;
            } else if(gesture === 'palm') {
                vx += (Math.random()-0.5)*0.05; vy += (Math.random()-0.5)*0.05; vz += (Math.random()-0.5)*0.05;
                vx += px * 0.02; vy += py * 0.02; vz += pz * 0.02;
            } else {
                vx += (originalPos[ix]-px) * 0.02;
                vy += (originalPos[ix+1]-py) * 0.02;
                vz += (originalPos[ix+2]-pz) * 0.02;
            }

            // 3. ç‰©ç†
            vx *= 0.9; vy *= 0.9; vz *= 0.9;
            px += vx; py += vy; pz += vz;

            pos[ix] = px; pos[ix+1] = py; pos[ix+2] = pz;
            vel[ix] = vx; vel[ix+1] = vy; vel[ix+2] = vz;

            // æ›´æ–°çŸ©é˜µ
            dummy.position.set(px, py, pz);
            dummy.rotation.x += vx*10;
            dummy.rotation.y += vy*10;
            dummy.updateMatrix();
            meshSystem.setMatrixAt(i, dummy.matrix);
            
            // å˜è‰²
            const color = new THREE.Color();
            if(gesture === 'fist') color.setHex(0xff0000);
            else if(gesture === 'palm') color.setHex(0xffff00);
            else color.setHSL(Math.sin(i+px)*0.5+0.5, 1.0, 0.5);
            
            meshSystem.setColorAt(i, color);
        }

        meshSystem.instanceMatrix.needsUpdate = true;
        meshSystem.instanceColor.needsUpdate = true;
        
        stage.children[0].rotation.y += 0.01;
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
