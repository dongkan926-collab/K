<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DBZ Scouter XR</title>
    <style>
        /* 引入复古字体 */
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'VT323', monospace;
        }

        /* 启动界面 */
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 20, 0, 0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 9999;
        }

        button {
            padding: 20px 40px; font-size: 24px; color: #0f0; background: rgba(0,0,0,0.8);
            border: 2px solid #0f0; border-radius: 10px; font-family: 'VT323', monospace;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
        }

        /* 探测器 HUD 界面 (AR模式下显示) */
        #scouter-ui {
            display: none; /* 初始隐藏 */
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            box-sizing: border-box;
        }

        /* 装饰框 */
        .lens-frame {
            position: absolute; top: 20px; bottom: 20px; left: 20px; right: 20px;
            border: 2px solid rgba(0, 255, 0, 0.3);
            border-radius: 30px;
            box-shadow: inset 0 0 50px rgba(0, 255, 0, 0.1);
        }

        /* 战斗力数值 */
        #power-box {
            position: absolute; top: 30%; right: 15%;
            text-align: right;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        .label { font-size: 20px; opacity: 0.7; }
        #power-val { font-size: 80px; line-height: 1; font-weight: bold; }
        
        /* 状态指示 */
        #status-text {
            position: absolute; bottom: 15%; width: 100%;
            text-align: center; font-size: 30px; color: #0f0;
            text-shadow: 0 0 5px #0f0;
            animation: blink 0.5s infinite alternate;
        }

        /* 瞄准准星 (三角形) */
        /* 注意：这个是UI层准星，我们主要用3D层的Reticle，这个作为辅助 */
        #ui-crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 60px; height: 60px;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 50%;
        }

        @keyframes blink { from { opacity: 1; } to { opacity: 0.3; } }
        
        .high-power { color: #f33 !important; text-shadow: 0 0 10px #f00 !important; }
    </style>

    <!-- 解决模块加载问题，使用 unpkg -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<!-- 启动页 -->
<div id="launcher">
    <h1 style="color:#0f0; font-size: 40px; margin-bottom: 20px;">SCOUTER SYSTEM v1.0</h1>
    <button id="btn-start">BOOT SYSTEM (AR)</button>
    <p style="color:#0a0; margin-top:20px;">Gesture: Hook Index Finger to Lock Target</p>
    <div id="debug-log" style="color:red; font-size:14px; position:absolute; bottom:10px;"></div>
</div>

<!-- AR HUD 层 -->
<div id="scouter-ui">
    <div class="lens-frame"></div>
    <div id="ui-crosshair"></div>
    <div id="power-box">
        <div class="label">BATTLE POWER</div>
        <div id="power-val">0</div>
    </div>
    <div id="status-text">SCANNING MODE</div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

    // 简易调试工具
    function debug(msg) {
        console.log(msg);
        // 如果是严重错误，显示在屏幕上
        if(msg.includes("Error") || msg.includes("Fail")) {
            document.getElementById('debug-log').innerText = msg;
        }
    }

    let camera, scene, renderer;
    let hand1, hand2;
    let reticle; // 3D三角形光标
    let targetMesh; // 识别后的轮廓
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    
    // 逻辑状态
    let state = 'SCANNING'; // SCANNING, LOCKED, RESULT
    let scanTimer = null;
    
    const uiPowerVal = document.getElementById('power-val');
    const uiStatus = document.getElementById('status-text');
    const uiLayer = document.getElementById('scouter-ui');

    document.getElementById('btn-start').addEventListener('click', onStartAR);

    async function onStartAR() {
        if (!navigator.xr) return alert("WebXR not supported");

        try {
            // Samsung Galaxy XR 关键点：请求 dom-overlay
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local', 'hit-test'],
                optionalFeatures: ['hand-tracking', 'dom-overlay'],
                domOverlay: { root: document.body }
            });

            document.getElementById('launcher').style.display = 'none';
            uiLayer.style.display = 'block'; // 显示 HUD
            initThree(session);
        } catch (e) {
            alert("启动失败: " + e.message);
        }
    }

    function initThree(session) {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);
        // 注意：不要 append renderer.domElement，因为 dom-overlay 模式下浏览器会自动处理
        
        session.addEventListener('end', () => location.reload());

        // 灯光
        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(0, 5, 0);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // 1. 创建瞄准用的三角形 (Reticle)
        // 这是一个平躺的绿色三角环，会贴合墙面/地面/人体
        const reticleGeo = new THREE.RingGeometry(0.1, 0.12, 3).rotateX(-Math.PI / 2);
        const reticleMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        reticle = new THREE.Mesh(reticleGeo, reticleMat);
        reticle.matrixAutoUpdate = false; 
        reticle.visible = false;
        scene.add(reticle);

        // 2. 初始化手势追踪
        const handModelFactory = new XRHandModelFactory();
        
        // 辅助函数：创建不可见的手部逻辑模型，只获取数据
        function setupHand(index) {
            const hand = renderer.xr.getHand(index);
            // 这里为了性能和视觉干扰，我们不加载完整的手部 Mesh，只用关节数据
            // 如果想看手，可以取消下面注释
            // hand.add(handModelFactory.createHandModel(hand, "mesh")); 
            scene.add(hand);
            return hand;
        }
        
        hand1 = setupHand(0);
        hand2 = setupHand(1);

        renderer.setAnimationLoop(render);
    }

    // --- 逻辑核心：勾手检测 ---
    function checkFingerHook(hand) {
        if (!hand || !hand.joints) return false;
        
        const tip = hand.joints['index-finger-tip'];
        const proximal = hand.joints['index-finger-phalanx-proximal']; // 食指根部关节
        const wrist = hand.joints['wrist'];

        if (!tip || !proximal || !wrist) return false;

        // 逻辑：如果 指尖到手腕的距离 < 根部到手腕的距离，说明手指弯曲指向掌心了
        // 或者简单的：指尖到手腕距离非常短
        const dTip = tip.position.distanceTo(wrist.position);
        
        // 通常成年人张开手，食指尖到手腕约 15-18cm
        // 勾手时，这个距离会缩短到 8-10cm 以下
        return dTip < 0.10; 
    }

    // --- 逻辑核心：锁定与计算 ---
    function lockTarget(position, distance) {
        state = 'LOCKED';
        reticle.visible = false; // 隐藏准星
        uiStatus.innerText = "TARGET LOCKED...";
        
        // 1. 生成轮廓 (绿色线框球)
        // 距离越近，认为物体越大，轮廓稍微放大一点
        const size = Math.max(0.2, distance * 0.25); 
        const geo = new THREE.IcosahedronGeometry(size, 1);
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, 
            wireframe: true,
            transparent: true, opacity: 0.6
        });
        targetMesh = new THREE.Mesh(geo, mat);
        targetMesh.position.copy(position);
        scene.add(targetMesh);

        // 2. 计算战斗力动画
        // 距离越近 (distance小)，基础分越高
        const basePower = Math.floor(1000 + (3000 / (distance + 0.1)));
        const finalPower = Math.min(10000, basePower + Math.floor(Math.random() * 2000));
        
        let displayVal = 0;
        
        // 播放快速跳动动画
        if (scanTimer) clearInterval(scanTimer);
        let steps = 0;
        
        scanTimer = setInterval(() => {
            steps++;
            // 随机乱跳
            uiPowerVal.innerText = Math.floor(Math.random() * 9999);
            uiStatus.innerText = "ANALYZING" + ".".repeat(steps % 4);
            
            // 轮廓旋转特效
            if(targetMesh) {
                targetMesh.rotation.y += 0.2;
                targetMesh.rotation.x += 0.1;
                // 忽大忽小
                const s = 1 + Math.sin(steps * 0.5) * 0.1;
                targetMesh.scale.set(s,s,s);
            }

            // 1.5秒后出结果
            if (steps > 30) {
                clearInterval(scanTimer);
                showFinalResult(finalPower);
            }
        }, 50);
    }

    function showFinalResult(power) {
        state = 'RESULT';
        uiPowerVal.innerText = power;
        
        if (power > 8000) {
            uiStatus.innerText = "IT'S OVER 9000!!!";
            uiStatus.classList.add('high-power');
            uiPowerVal.style.color = '#f33';
            if(targetMesh) targetMesh.material.color.setHex(0xff0000);
        } else {
            uiStatus.innerText = "TRASH.";
            uiStatus.classList.remove('high-power');
            uiPowerVal.style.color = '#0f0';
        }

        // 5秒后重置
        setTimeout(resetSystem, 5000);
    }

    function resetSystem() {
        state = 'SCANNING';
        uiStatus.innerText = "SCANNING MODE";
        uiStatus.classList.remove('high-power');
        uiPowerVal.innerText = "0";
        uiPowerVal.style.color = '#0f0';
        
        if (targetMesh) {
            scene.remove(targetMesh);
            targetMesh = null;
        }
    }

    function render(timestamp, frame) {
        if (frame) {
            const referenceSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();

            // 1. 射线检测 (Hit Test) - 寻找现实世界表面
            if (state === 'SCANNING') {
                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        
                        reticle.visible = true;
                        reticle.matrix.fromArray(pose.transform.matrix);
                        
                        // 检测勾手动作
                        if (checkFingerHook(hand1) || checkFingerHook(hand2)) {
                            // 计算距离
                            const camPos = camera.position;
                            const targetPos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
                            const dist = camPos.distanceTo(targetPos);
                            
                            lockTarget(targetPos, dist);
                        }
                    } else {
                        reticle.visible = false;
                    }
                }
            } else if (state === 'LOCKED' || state === 'RESULT') {
                // 如果已经锁定了，保持轮廓旋转
                if (targetMesh) {
                    targetMesh.rotation.y += 0.01;
                }
            }
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
