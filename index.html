<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DBZ Scouter - Point to Scan</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'VT323', monospace;
        }

        /* 启动层 */
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 10, 0, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 9999;
            color: #0f0;
        }

        button {
            padding: 15px 40px; font-size: 24px; color: #000; background: #0f0;
            border: none; border-radius: 4px; font-family: 'VT323', monospace; font-weight: bold;
            cursor: pointer; margin-top: 20px;
        }
        button:active { background: #0a0; }

        /* 战斗力探测器 UI 覆盖层 */
        #scouter-ui {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            box-sizing: border-box;
        }

        /* 经典的绿色半透明边框 */
        .hud-frame {
            position: absolute; top: 10px; bottom: 10px; left: 10px; right: 10px;
            border: 2px solid rgba(0, 255, 0, 0.4);
            border-radius: 20px;
            background: radial-gradient(circle, transparent 60%, rgba(0, 50, 0, 0.2) 100%);
        }

        /* 屏幕中心的辅助十字准心 (UI层) */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            border: 1px dashed rgba(0, 255, 0, 0.4);
            border-radius: 50%;
        }

        /* 战斗力数值面板 */
        #power-panel {
            position: absolute; top: 30%; right: 10%;
            display: flex; flex-direction: column; align-items: flex-end;
        }
        
        .label { font-size: 24px; color: #0f0; opacity: 0.8; letter-spacing: 2px; }
        
        #power-val { 
            font-size: 90px; color: #0f0; line-height: 0.9; 
            text-shadow: 0 0 10px rgba(0,255,0,0.8);
            font-weight: bold;
        }

        /* 底部状态栏 */
        #status-bar {
            position: absolute; bottom: 20%; width: 100%;
            text-align: center; font-size: 28px; color: #0f0;
            text-transform: uppercase; letter-spacing: 3px;
        }
        
        /* 装饰用的外星文字 */
        .alien-text {
            font-size: 14px; opacity: 0.5; margin-top: 5px; color: #0f0;
            writing-mode: vertical-rl; position: absolute; left: 5%; top: 30%;
        }

        /* 动画类 */
        .blink { animation: blink 0.5s infinite alternate; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.4; } }
        
        .high-energy { color: #ff3333 !important; text-shadow: 0 0 15px #ff0000 !important; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="launcher">
    <div style="font-size: 60px;">⚡ SCOUTER ⚡</div>
    <div style="margin-top: 10px; text-align: center;">
        <div>1. LOOK at Target (Triangle)</div>
        <div>2. POINT with RIGHT HAND to Scan</div>
    </div>
    <button id="btn-start">ACTIVATE</button>
</div>

<div id="scouter-ui">
    <div class="hud-frame"></div>
    <div id="crosshair"></div>
    <div class="alien-text">⍙⍝ ⍺⍵⍫ ⍱⍯⌬ ⌭⌮</div>
    
    <div id="power-panel">
        <div class="label">POWER LEVEL</div>
        <div id="power-val">0</div>
    </div>
    
    <div id="status-bar" class="blink">SEARCHING...</div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

    let camera, scene, renderer;
    let rightHand; // 只关注右手
    let reticle; // 地面/物体上的光标
    let targetMesh; // 扫描出的轮廓
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    // 状态机
    let state = 'SEARCHING'; // SEARCHING -> SCANNING -> RESULT
    let scanInterval = null;

    const UI = {
        overlay: document.getElementById('scouter-ui'),
        powerVal: document.getElementById('power-val'),
        status: document.getElementById('status-bar'),
        startBtn: document.getElementById('btn-start'),
        launcher: document.getElementById('launcher')
    };

    UI.startBtn.addEventListener('click', startAR);

    async function startAR() {
        if (!navigator.xr) return alert("WebXR not supported");
        
        try {
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local', 'hit-test'],
                optionalFeatures: ['hand-tracking', 'dom-overlay'],
                domOverlay: { root: document.body }
            });
            
            UI.launcher.style.display = 'none';
            UI.overlay.style.display = 'block';
            
            initThree(session);
        } catch (e) {
            alert("Error: " + e.message);
        }
    }

    function initThree(session) {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);

        session.addEventListener('end', () => location.reload());

        // 环境光
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        // --- 1. 瞄准 Reticle (跟随视线) ---
        const reticleGeo = new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2);
        const reticleMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        reticle = new THREE.Mesh(reticleGeo, reticleMat);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // --- 2. 轮廓模拟 (Target Mesh) ---
        // 初始隐藏，锁定时出现
        const targetGeo = new THREE.IcosahedronGeometry(0.3, 1);
        const targetMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.5 
        });
        targetMesh = new THREE.Mesh(targetGeo, targetMat);
        targetMesh.visible = false;
        scene.add(targetMesh);

        // --- 3. 右手追踪 ---
        const handModelFactory = new XRHandModelFactory();
        
        // 索引 1 通常是右手，但最好还是检查 handedness，这里简化处理
        rightHand = renderer.xr.getHand(1); 
        // 添加一个隐形的模型来获取数据，或者显示的网格方便你看到手在哪
        // 既然你要“指”，看到手比较好
        rightHand.add(handModelFactory.createHandModel(rightHand, "mesh"));
        scene.add(rightHand);

        renderer.setAnimationLoop(render);
    }

    // --- 核心算法：检测“指向”姿势 ---
    function isPointing(hand) {
        if (!hand || !hand.joints) return false;

        const wrist = hand.joints['wrist'];
        const indexTip = hand.joints['index-finger-tip'];
        const middleTip = hand.joints['middle-finger-tip'];
        const ringTip = hand.joints['ring-finger-tip'];

        if (!wrist || !indexTip || !middleTip) return false;

        // 逻辑：
        // 1. 食指伸直：食指尖到手腕的距离 > 阈值 (约0.12m以上)
        // 2. 中指弯曲：中指尖到手腕的距离 < 阈值 (约0.10m以下)
        // 这样可以区分“五指张开”和“指向”
        
        const dWristIndex = wrist.position.distanceTo(indexTip.position);
        const dWristMiddle = wrist.position.distanceTo(middleTip.position);

        // 你可以根据实际体验微调这两个数值
        const isIndexStraight = dWristIndex > 0.12; 
        const isMiddleCurled = dWristMiddle < 0.11; 
        
        // 且中指必须明显比食指短 (防止大手掌误判)
        return isIndexStraight && (dWristIndex > dWristMiddle + 0.02);
    }

    // --- 业务逻辑：开始扫描 ---
    function startScan(position, distance) {
        if (state !== 'SEARCHING') return; // 防止重复触发
        state = 'SCANNING';

        // 1. 锁定视觉效果
        reticle.visible = false; // 隐藏瞄准器
        targetMesh.visible = true;
        targetMesh.position.copy(position);
        
        // 根据距离调整大小
        const size = Math.max(0.2, distance * 0.25);
        targetMesh.scale.set(size, size, size);

        // 2. UI 变更
        UI.status.innerText = "CALCULATING...";
        UI.status.style.color = "#ffff00";

        // 3. 计算数值
        const rawPower = 1000 + (4000 / distance) + Math.random() * 4000;
        const finalPower = Math.min(10000, Math.floor(rawPower));

        // 4. 动画循环
        let steps = 0;
        scanInterval = setInterval(() => {
            steps++;
            // 随机数跳动
            UI.powerVal.innerText = Math.floor(Math.random() * 9999);
            
            // 轮廓旋转
            targetMesh.rotation.y += 0.2;
            targetMesh.rotation.z += 0.1;

            if (steps > 40) { // 2秒左右
                clearInterval(scanInterval);
                finishScan(finalPower);
            }
        }, 50);
    }

    function finishScan(power) {
        state = 'RESULT';
        UI.powerVal.innerText = power;

        if (power > 8000) {
            UI.status.innerText = "IT'S OVER 9000!!!";
            UI.status.classList.add('high-energy');
            UI.powerVal.classList.add('high-energy');
            targetMesh.material.color.setHex(0xff0000);
        } else {
            UI.status.innerText = "TARGET IDENTIFIED";
            UI.status.classList.remove('high-energy');
            UI.powerVal.classList.remove('high-energy');
            targetMesh.material.color.setHex(0x00ff00);
        }

        // 5秒后自动重置
        setTimeout(resetScanner, 5000);
    }

    function resetScanner() {
        state = 'SEARCHING';
        UI.status.innerText = "SEARCHING...";
        UI.status.classList.remove('high-energy');
        UI.powerVal.classList.remove('high-energy');
        UI.powerVal.style.color = '#0f0';
        UI.powerVal.innerText = "0";
        
        targetMesh.visible = false;
        targetMesh.material.color.setHex(0x00ff00);
    }

    // --- 渲染循环 ---
    function render(timestamp, frame) {
        if (frame) {
            const referenceSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();

            // 1. Raycasting (视线检测)
            if (state === 'SEARCHING') {
                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        
                        reticle.visible = true;
                        reticle.matrix.fromArray(pose.transform.matrix);

                        // 2. 在瞄准状态下，检测右手姿势
                        if (rightHand && isPointing(rightHand)) {
                            // 获取距离
                            const camPos = camera.position;
                            const targetPos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
                            const dist = camPos.distanceTo(targetPos);
                            
                            startScan(targetPos, dist);
                        }

                    } else {
                        reticle.visible = false;
                    }
                }
            } else {
                // 如果处于 LOCKED 或 RESULT 状态，保持轮廓旋转
                if (targetMesh.visible) {
                    targetMesh.rotation.y += 0.01;
                }
            }
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
