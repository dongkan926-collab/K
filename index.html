<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galaxy XR æ’’å¸æ¨¡æ‹Ÿå™¨</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: "Microsoft YaHei", sans-serif; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #2b0a0a 0%, #000 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 9999; color: #fff;
        }

        h1 {
            font-size: 2.2rem; margin-bottom: 5px; color: #E5526F; 
            text-shadow: 0 0 10px rgba(229, 82, 111, 0.5); letter-spacing: 2px;
        }

        .subtitle { font-size: 1rem; color: #ccc; margin-bottom: 40px; opacity: 0.8; }

        #start-btn {
            padding: 15px 50px; font-size: 1.4rem; font-weight: bold;
            color: #fff; background: linear-gradient(to right, #E5526F, #D90429);
            border: none; border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 20px rgba(229, 82, 111, 0.4);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(229, 82, 111, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(229, 82, 111, 0); }
            100% { box-shadow: 0 0 0 0 rgba(229, 82, 111, 0); }
        }

        .guide-container {
            margin-top: 30px; display: grid; grid-template-columns: 1fr; gap: 10px;
            width: 80%; max-width: 300px; text-align: center;
        }
        .guide-item { background: rgba(255,255,255,0.1); padding: 8px; border-radius: 8px; font-size: 0.9rem; }

        #ar-info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #fff; pointer-events: none; 
            text-shadow: 0 0 4px #000; font-size: 18px; font-weight: bold;
            display: none; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>åœŸè±ªæ¨¡æ‹Ÿå™¨</h1>
        <div class="subtitle">Galaxy XR å¢å¼ºç°å®ä½“éªŒ</div>
        <button id="start-btn" disabled>æ­£åœ¨åˆå§‹åŒ–...</button>
        <div class="guide-container">
            <div class="guide-item">ğŸ‘‰ <b>å‰‘æŒ‡æŒ‡å‘äºº</b>ï¼šç–¯ç‹‚æ’’é’± (+100)</div>
            <div class="guide-item">âœŠ <b>æ¡æ‹³</b>ï¼šå¬å›é’ç¥¨ (è¡¥å……å¼¹è¯)</div>
        </div>
    </div>

    <div id="ar-info">ç­‰å¾…æŒ‡ä»¤...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let container, camera, scene, renderer;
        let hand;
        
        // é’ç¥¨æ± 
        const BILLS = [];
        const BILL_COUNT = 50; // 50å¼ å¤§é’
        
        // æµ®åŠ¨æ–‡å­—æ±  (+100ç‰¹æ•ˆ)
        const FLOAT_TEXTS = [];
        
        let currentMode = 'IDLE'; 
        let lastTime = 0;
        let shootTimer = 0; // æ§åˆ¶å°„é€Ÿ

        // æŒ‰é’® UI
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');
        const arInfo = document.getElementById('ar-info');

        init();

        // --- 1. ç»˜åˆ¶ 100å…ƒ äººæ°‘å¸çº¹ç† ---
        function createRMBTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256; // 2:1 æ¯”ä¾‹
            const ctx = canvas.getContext('2d');
            
            // 1. ç²‰çº¢åº•è‰²
            ctx.fillStyle = '#F8BBD0'; 
            ctx.fillRect(0, 0, 512, 256);
            
            // 2. çº¢è‰²ä¸»è°ƒ (æ¸å˜)
            const grd = ctx.createLinearGradient(0, 0, 512, 0);
            grd.addColorStop(0, '#E91E63');
            grd.addColorStop(1, '#C2185B');
            ctx.fillStyle = grd;
            ctx.fillRect(20, 20, 472, 216);

            // 3. æ¯›çˆ·çˆ·å¤´åƒåœˆ (å³ä¾§)
            ctx.beginPath();
            ctx.arc(350, 128, 80, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fill();

            // 4. "100" å­—æ ·
            ctx.fillStyle = '#FCE4EC'; // æµ…ç²‰å­—
            ctx.font = "bold 120px Arial";
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 10;
            ctx.fillText("100", 50, 160);

            // 5. "ä¸­å›½äººæ°‘é“¶è¡Œ" (ç®€åŒ–)
            ctx.font = "bold 30px Microsoft YaHei";
            ctx.fillText("ä¸­å›½äººæ°‘é“¶è¡Œ", 50, 60);

            // 6. å›½å¾½å ä½
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(80, 200, 30, 0, Math.PI*2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        // --- 2. ç»˜åˆ¶ "+100" æµ®åŠ¨æ–‡å­—çº¹ç† ---
        function createPlus100Texture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.font = "bold 80px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // æè¾¹
            ctx.strokeStyle = '#D62828';
            ctx.lineWidth = 8;
            ctx.strokeText("+100", 128, 64);
            
            // å¡«å……é‡‘è‰²
            ctx.fillStyle = '#FFD700';
            ctx.fillText("+100", 128, 64);
            
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // å…‰ç…§
            const light = new THREE.HemisphereLight(0xffffff, 0x444444, 2.0);
            scene.add(light);

            // åˆ›å»ºé’ç¥¨
            createBills();

            // æ‰‹éƒ¨è¿½è¸ª
            hand = renderer.xr.getHand(0);
            scene.add(hand);

            window.addEventListener('resize', onResize);

            // æ£€æµ‹ WebXR
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        startBtn.innerText = "å¼€å§‹æ’’é’±";
                        startBtn.disabled = false;
                        startBtn.addEventListener('click', onStartAR);
                    } else {
                        startBtn.innerText = "ä¸æ”¯æŒ WebXR";
                    }
                });
            }
        }

        function createBills() {
            const tex = createRMBTexture();
            const geo = new THREE.PlaneGeometry(0.14, 0.07); // 14cm x 7cm çœŸå®æ¯”ä¾‹
            const mat = new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide });

            for (let i = 0; i < BILL_COUNT; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                
                // åˆå§‹ä½ç½®ï¼šç¯ç»•åœ¨ç”¨æˆ·å‘¨å›´ 1.5ç±³ - 2.5ç±³ å¤„
                const angle = Math.random() * Math.PI * 2;
                const radius = 1.0 + Math.random() * 1.5;
                const y = (Math.random() - 0.5) * 1.5; // ä¸Šä¸‹é«˜åº¦
                
                mesh.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
                
                scene.add(mesh);
                BILLS.push({
                    mesh: mesh,
                    state: 'IDLE', // IDLE (æ¼‚æµ®), FLYING (é£å‘äºº), DONE (å·²éšè—)
                    velocity: new THREE.Vector3(),
                    targetPos: new THREE.Vector3(),
                    rotSpeed: Math.random() * 2,
                    idleBasePos: mesh.position.clone(), // è®°ä½å¾…æœºä½ç½®
                    idlePhase: Math.random() * Math.PI * 2
                });
            }
        }

        // ç”Ÿæˆ "+100" ç‰¹æ•ˆ
        const plusTex = createPlus100Texture();
        const plusMat = new THREE.SpriteMaterial({ map: plusTex, transparent: true });
        
        function spawnPlus100(position) {
            const sprite = new THREE.Sprite(plusMat);
            sprite.position.copy(position);
            sprite.scale.set(0.3, 0.15, 1); // è°ƒæ•´å¤§å°
            scene.add(sprite);
            
            FLOAT_TEXTS.push({
                sprite: sprite,
                life: 1.0, // å­˜æ´» 1 ç§’
                startY: position.y
            });
        }

        async function onStartAR() {
            const session = await navigator.xr.requestSession('immersive-ar', { optionalFeatures: ['hand-tracking'] });
            renderer.xr.setReferenceSpaceType('local');
            renderer.xr.setSession(session);
            overlay.style.display = 'none';
            arInfo.style.display = 'block';
            session.addEventListener('end', () => {
                overlay.style.display = 'flex';
                arInfo.style.display = 'none';
            });
            animate();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (renderer.xr.isPresenting) {
                updateHandLogic(dt);
                updateBills(dt, timestamp);
                updateEffects(dt);
            }
            renderer.render(scene, camera);
        }

        function updateHandLogic(dt) {
            const joints = hand.joints;
            if (!joints || !joints['wrist']) return;

            const indexTip = joints['index-finger-tip'].position;
            const middleTip = joints['middle-finger-tip'].position;
            const wrist = joints['wrist'].position;
            const pinkyTip = joints['pinky-finger-tip'].position;

            const distIndexMiddle = indexTip.distanceTo(middleTip);
            const distPinkyWrist = pinkyTip.distanceTo(wrist);
            const distIndexWrist = indexTip.distanceTo(wrist);

            // 1. æ¡æ‹³æ£€æµ‹ï¼šå¬å›é’ç¥¨
            if (distIndexWrist < 0.10 && distPinkyWrist < 0.08) {
                if (currentMode !== 'FIST') {
                    currentMode = 'FIST';
                    arInfo.innerText = "çŠ¶æ€ï¼šå¬å›é’ç¥¨ (è¡¥å¼¹)";
                    recallBills();
                }
                return;
            }

            // 2. å‰‘æŒ‡æ£€æµ‹ï¼šå°„å‡»
            // é£ŸæŒ‡ä¸­æŒ‡å¹¶æ‹¢ï¼Œä¸”ç¦»æ‰‹è…•è¿œ
            if (distIndexMiddle < 0.04 && distIndexWrist > 0.12) {
                currentMode = 'SHOOT';
                arInfo.innerText = "çŠ¶æ€ï¼šæ’’é’±ä¸­ï¼(+100)";
                
                // è®¡ç®—å°„å‡»æ–¹å‘ (æ‰‹è…• -> é£ŸæŒ‡å°–)
                const shootDir = new THREE.Vector3().subVectors(indexTip, wrist).normalize();
                
                // å°„å‡»è®¡æ—¶å™¨ (æ¯ 0.1 ç§’å‘å°„ä¸€å¼ )
                shootTimer += dt;
                if (shootTimer > 0.08) { 
                    shootTimer = 0;
                    fireOneBill(indexTip, shootDir);
                }
            } else {
                currentMode = 'IDLE';
                arInfo.innerText = "çŠ¶æ€ï¼šå¾…æœº (é’ç¥¨ç¯ç»•)";
            }
        }

        function fireOneBill(startPos, direction) {
            // æ‰¾ä¸€å¼ å¤„äº IDLE çŠ¶æ€çš„é’ç¥¨å‘å°„
            const bill = BILLS.find(b => b.state === 'IDLE');
            if (bill) {
                bill.state = 'FLYING';
                bill.mesh.visible = true;
                
                // è®¾ç½®èµ·å§‹ç‚¹ä¸ºæŒ‡å°–
                bill.mesh.position.copy(startPos);
                
                // è®¾ç½®ç›®æ ‡ç‚¹ï¼šæ²¿ç€æ‰‹æŒ‡æ–¹å‘å‰æ–¹ 3 ç±³ (æ¨¡æ‹Ÿæ‰“åˆ°äºº)
                // å¦‚æœæœ‰çœŸå®çš„ HitTest API è¿™é‡Œå¯ä»¥æ›¿æ¢ï¼Œä½†å‰æ–¹3ç±³æ•ˆæœæœ€ç¨³å®š
                bill.targetPos.copy(startPos).add(direction.multiplyScalar(3.0));
                
                // è®¾ç½®æœå‘
                bill.mesh.lookAt(bill.targetPos);
                bill.mesh.rotateX(-Math.PI/2); // è®©é’±å¹³ç€é£ï¼Œæ›´åƒé£ç‰Œ
            }
        }

        function recallBills() {
            // æ‰€æœ‰é’ç¥¨ç¬é—´é‡ç½®åˆ°å‘¨å›´éšæœºä½ç½®
            BILLS.forEach(b => {
                b.state = 'IDLE';
                b.mesh.visible = true;
                // éšæœºé‡ç½®ä½ç½®
                const angle = Math.random() * Math.PI * 2;
                const radius = 1.0 + Math.random() * 1.0;
                b.idleBasePos.set(Math.cos(angle)*radius, (Math.random()-0.5)*1.5, Math.sin(angle)*radius);
            });
        }

        function updateBills(dt, time) {
            const t = time * 0.001;
            
            BILLS.forEach(b => {
                if (b.state === 'IDLE') {
                    // ç¯ç»•å‘¼å¸æ•ˆæœ (åœ¨ä½ å‘¨å›´æ¼‚æµ®)
                    const floatY = Math.sin(t * 1.5 + b.idlePhase) * 0.1;
                    const target = b.idleBasePos.clone();
                    target.y += floatY;
                    
                    // å¹³æ»‘ç§»åŠ¨åˆ°å¾…æœºä½ç½®
                    b.mesh.position.lerp(target, 0.1);
                    
                    // ç¼“æ…¢è‡ªè½¬
                    b.mesh.rotation.y += b.rotSpeed * dt;
                    b.mesh.rotation.z = Math.sin(t + b.idlePhase) * 0.1;

                } else if (b.state === 'FLYING') {
                    // é£å‘ç›®æ ‡
                    const speed = 6.0; // é£è¡Œé€Ÿåº¦ (ç±³/ç§’)
                    const direction = new THREE.Vector3().subVectors(b.targetPos, b.mesh.position).normalize();
                    const dist = b.mesh.position.distanceTo(b.targetPos);

                    // ç§»åŠ¨
                    b.mesh.position.add(direction.multiplyScalar(speed * dt));
                    
                    // é£ç‰Œæ—‹è½¬ç‰¹æ•ˆ
                    b.mesh.rotateZ(15 * dt); // é«˜é€Ÿè‡ªæ—‹

                    // å‘½ä¸­æ£€æµ‹ (è·ç¦»å°äº 0.2ç±³)
                    if (dist < 0.2) {
                        b.state = 'DONE';
                        b.mesh.visible = false; // æ¶ˆå¤±
                        spawnPlus100(b.mesh.position); // ç”Ÿæˆ +100 å­—æ ·
                    }
                }
            });
        }

        function updateEffects(dt) {
            // æ›´æ–°æ‰€æœ‰ +100 æ–‡å­—
            for (let i = FLOAT_TEXTS.length - 1; i >= 0; i--) {
                const effect = FLOAT_TEXTS[i];
                effect.life -= dt;
                
                // å‘ä¸Šé£˜
                effect.sprite.position.y += dt * 0.5;
                // å˜é€æ˜
                effect.sprite.material.opacity = effect.life; // life 1 -> 0
                
                if (effect.life <= 0) {
                    scene.remove(effect.sprite);
                    FLOAT_TEXTS.splice(i, 1);
                }
            }
        }
    </script>
</body>
</html>
