<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR 粒子手势交互</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-family: sans-serif;
            pointer-events: none;
            z-index: 10;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="info">
        WebXR 粒子系统<br/>
        左手握拳: 扩散 | 左手张开(大爪): 篮球大小 | 双手张开: 网球大小
    </div>

    <!-- 引入 Three.js 和相关库 (使用 ESM 模块) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let container;
        let camera, scene, renderer;
        let hand1, hand2; // hand1: left, hand2: right
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;

        // 粒子系统变量
        let particleSystem;
        let particlesData = [];
        const PARTICLE_COUNT = 3000;
        let targetSphereRadius = 0.12; // 默认篮球大小
        let targetCenter = new THREE.Vector3(0, 0, -0.5); // 默认前方
        let isGathering = false; // 是否在聚集状态

        // 状态机
        const STATE = {
            DIFFUSE: 0,    // 扩散
            BASKETBALL: 1, // 篮球 (左手大爪)
            TENNIS: 2      // 网球 (双手张开)
        };
        let currentState = STATE.DIFFUSE;

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            
            // 摄像头
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 100);
            
            // 渲染器设置
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true; // 开启WebXR
            container.appendChild(renderer.domElement);

            // 添加 AR 按钮
            // 必须请求 'hand-tracking' 功能
            const sessionInit = { requiredFeatures: ['hand-tracking'] };
            document.body.appendChild(ARButton.createButton(renderer, sessionInit));

            // 灯光
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0, 1, 0);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));

            // 初始化手柄/手势追踪
            setupHands();

            // 初始化粒子
            initParticles();

            window.addEventListener('resize', onWindowResize);
        }

        function setupHands() {
            // 我们需要区分左右手。在 Three.js WebXR 中：
            // 通常 inputSource.handedness 会告诉我们是 'left' 还是 'right'
            // 我们将在 render 循环中动态检测，或者在这里初始化容器
            
            const handModelFactory = new XRHandModelFactory();

            // Hand 1 (通常是左手，索引0，但这取决于控制器连接顺序，我们在逻辑中通过 handedness 判断)
            hand1 = renderer.xr.getHand(0);
            hand1.add(handModelFactory.createHandModel(hand1)); // 添加可视化模型（可选，用于调试）
            scene.add(hand1);

            // Hand 2 (通常是右手，索引1)
            hand2 = renderer.xr.getHand(1);
            hand2.add(handModelFactory.createHandModel(hand2));
            scene.add(hand2);
        }

        function initParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 初始随机位置
                const x = (Math.random() - 0.5) * 2;
                const y = (Math.random() - 0.5) * 2 + 1; // 稍微抬高一点
                const z = (Math.random() - 0.5) * 2 - 1;

                positions.push(x, y, z);

                // 颜色：青色到紫色渐变
                color.setHSL(Math.random() * 0.2 + 0.5, 1.0, 0.6);
                colors.push(color.r, color.g, color.b);

                // 存储每个粒子的物理数据
                particlesData.push({
                    velocity: new THREE.Vector3(0,0,0),
                    target: new THREE.Vector3()
                });
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.008,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 核心逻辑 ---

        // 计算手势状态
        function detectHandState(hand) {
            // 如果手未检测到关节
            if (!hand.joints || Object.keys(hand.joints).length === 0) return { visible: false };

            const joints = hand.joints;
            const wrist = joints['wrist'];
            
            if (!wrist) return { visible: false };

            // 计算指尖到手腕的平均距离来判断张开还是握拳
            const tips = ['index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip', 'thumb-tip'];
            let totalDist = 0;
            let count = 0;

            tips.forEach(tipName => {
                const tip = joints[tipName];
                if (tip) {
                    totalDist += tip.position.distanceTo(wrist.position);
                    count++;
                }
            });

            const avgDist = count > 0 ? totalDist / count : 0;
            
            // 阈值需要根据实际体验微调 (单位：米)
            // 握拳通常 < 0.08m (8cm)
            // 张开通常 > 0.10m (10cm)
            const isFist = avgDist < 0.08; 
            const isOpen = avgDist > 0.10;

            return {
                visible: true,
                isFist: isFist,
                isOpen: isOpen,
                wristPosition: wrist.position.clone(),
                // 估算手掌中心：大约在手腕往中指方向偏移一点
                palmPosition: joints['middle-finger-metacarpal'] ? joints['middle-finger-metacarpal'].position.clone() : wrist.position.clone()
            };
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            // 1. 获取左右手数据
            // WebXR 的 getHand(index) 不保证索引固定对应左右手，需检查 inputSource
            let leftHandState = { visible: false };
            let rightHandState = { visible: false };
            let leftHandObj = null;

            [hand1, hand2].forEach(hand => {
                if (hand.inputState && hand.inputState.handedness === 'left') {
                    leftHandState = detectHandState(hand);
                    leftHandObj = hand;
                } else if (hand.inputState && hand.inputState.handedness === 'right') {
                    rightHandState = detectHandState(hand);
                }
            });

            // 2. 逻辑判定
            // 默认扩散
            let nextState = STATE.DIFFUSE;
            let targetPos = new THREE.Vector3(0, 1.5, -1); // 默认扩散中心

            if (leftHandState.visible) {
                // 计算聚集位置：左手掌心上方 5cm (0.05m)
                // 简单的做法：取手掌位置，Y轴加 0.05 (在世界坐标系中)
                // 更严谨的做法是沿着手掌法线，但为了简单，假设手掌大致向上或向前，直接叠加偏移
                
                // 尝试获取更准确的"上方"：利用手腕到中指向量做参考
                // 这里简化：直接在世界坐标Y轴上加 0.05m
                targetPos.copy(leftHandState.palmPosition).add(new THREE.Vector3(0, 0.05, 0));

                if (leftHandState.isFist) {
                    // 左手握拳 -> 扩散
                    nextState = STATE.DIFFUSE;
                } else if (leftHandState.isOpen) {
                    // 左手张开
                    if (rightHandState.visible && rightHandState.isOpen) {
                        // 双手都张开 -> 网球 (小球)
                        nextState = STATE.TENNIS;
                    } else {
                        // 只有左手张开 (大爪子) -> 篮球 (大球)
                        nextState = STATE.BASKETBALL;
                    }
                }
            }

            currentState = nextState;
            targetCenter.copy(targetPos);

            // 3. 更新粒子
            updateParticles();

            renderer.render(scene, camera);
        }

        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            
            // 根据状态设定参数
            let radius = 0.5; // 扩散范围
            let attractionSpeed = 0.05;
            let noiseSpeed = 0.002;

            if (currentState === STATE.BASKETBALL) {
                radius = 0.12; // 篮球半径 12cm
                attractionSpeed = 0.1;
                isGathering = true;
            } else if (currentState === STATE.TENNIS) {
                radius = 0.033; // 网球半径 3.3cm
                attractionSpeed = 0.15; // 聚得更快
                isGathering = true;
            } else {
                // DIFFUSE
                radius = 1.0; 
                attractionSpeed = 0.01; // 慢慢飘
                isGathering = false;
                noiseSpeed = 0.01; // 扩散时噪点运动大
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const px = positions[i3];
                const py = positions[i3 + 1];
                const pz = positions[i3 + 2];
                const currentPos = new THREE.Vector3(px, py, pz);

                if (isGathering) {
                    // 计算球体表面目标点
                    // 算法：根据粒子ID生成一个固定的球体方向，乘以当前目标半径，加上目标中心
                    // 这样每个粒子都有属于自己在球体表面的"家"
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    
                    const tx = radius * Math.cos(theta) * Math.sin(phi);
                    const ty = radius * Math.sin(theta) * Math.sin(phi);
                    const tz = radius * Math.cos(phi);

                    const target = new THREE.Vector3(tx, ty, tz).add(targetCenter);
                    
                    // 线性插值移动
                    currentPos.lerp(target, attractionSpeed);
                } else {
                    // 扩散逻辑：模拟布朗运动或向四周炸开
                    // 这里我们让它们在目标中心周围的大范围内随机漂浮
                    // 或者是如果之前是聚集状态，现在要"炸开"
                    
                    // 简单的布朗运动
                    currentPos.x += (Math.random() - 0.5) * noiseSpeed * 2;
                    currentPos.y += (Math.random() - 0.5) * noiseSpeed * 2;
                    currentPos.z += (Math.random() - 0.5) * noiseSpeed * 2;
                    
                    // 稍微加一点重力或向上飘的效果
                    currentPos.y += 0.001; 
                }

                positions[i3] = currentPos.x;
                positions[i3 + 1] = currentPos.y;
                positions[i3 + 2] = currentPos.z;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
    </script>
</body>
</html>
