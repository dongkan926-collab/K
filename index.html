<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Vegeta Scouter XR</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', sans-serif; }
        
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 0, 0, 0.95); /* æ·±çº¢è‰²èƒŒæ™¯ */
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 999; color: #ffaa00;
        }

        button {
            padding: 15px 40px; font-size: 20px; 
            color: #000; background: #ffaa00; border: none; 
            border-radius: 2px; font-weight: bold; cursor: pointer; margin-top: 20px;
            box-shadow: 0 0 20px #ffaa00; text-transform: uppercase; letter-spacing: 2px;
        }

        #hud-status {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            color: #ffaa00; font-size: 16px; pointer-events: none; 
            text-shadow: 0 0 5px #ff0000; display: none; letter-spacing: 3px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="launcher">
    <h1 style="text-shadow: 0 0 10px #ff0000;">ELITE SAIYAN SCOUTER</h1>
    <p style="color: #fff; opacity: 0.8; font-size: 14px;">TARGET: VEGETA</p>
    <div style="border:1px solid #ff4400; padding:20px; background:rgba(20,0,0,0.8); margin-top:10px;">
        <p>ğŸ‘‰ <b>RIGHT HAND POINT</b>: SCAN TARGET</p>
        <p>âœŠ <b>LEFT HAND FIST</b>: RESET</p>
    </div>
    <button id="btn-start">ACTIVATE</button>
</div>

<div id="hud-status">SYSTEM READY</div>

<script type="module">
    import * as THREE from 'three';
    import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

    let camera, scene, renderer;
    let handLeft, handRight;
    
    // è§†è§‰å¯¹è±¡
    let aimCursor;      // ç„å‡†ç”¨çš„åå­—
    let targetGroup;    // é”å®šåçš„ç‰¹æ•ˆç»„ (æ¡†+æŒ‡é’ˆ)
    let powerSprite;    // æˆ˜æ–—åŠ›UI
    let laserPlane;     // ä¸Šä¸‹æ‰«æçš„å…‰
    
    // é€»è¾‘æ§åˆ¶
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let isLocked = false;
    let scanInterval = null;

    // UI ç”»å¸ƒé…ç½® (çº¢è‰²ç³»)
    const THEME_COLOR = "#ffaa00"; // ç¥ç€æ©™
    const THEME_BG = "rgba(20, 0, 0, 0.85)"; // æ·±çº¢é»‘
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 256;

    document.getElementById('btn-start').addEventListener('click', initAR);

    async function initAR() {
        if (!navigator.xr) return alert("WebXR unsupported");
        const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['local', 'hit-test'],
            optionalFeatures: ['hand-tracking', 'dom-overlay'],
            domOverlay: { root: document.body }
        });
        document.getElementById('launcher').style.display = 'none';
        document.getElementById('hud-status').style.display = 'block';
        initScene(session);
    }

    function initScene(session) {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);
        session.addEventListener('end', () => location.reload());

        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(0, 5, 2);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- 1. ç„å‡†å…‰æ ‡ (åå­—å‡†æ˜Ÿ) ---
        // ä½¿ç”¨ Sprite æè´¨ï¼Œè¿™æ ·å®ƒæ°¸è¿œé¢å‘æ‘„åƒæœºï¼Œä¸ä¼šå› ä¸ºè´´åœ¨ä¸å¹³æ•´è¡¨é¢è€Œå˜å½¢
        const cursorTexture = createCursorTexture();
        const cursorMat = new THREE.SpriteMaterial({ map: cursorTexture, color: 0xffffff, transparent: true, opacity: 0.8 });
        aimCursor = new THREE.Sprite(cursorMat);
        aimCursor.scale.set(0.08, 0.08, 1); // å°å·§ç²¾å‡†
        aimCursor.visible = false;
        scene.add(aimCursor);

        // --- 2. ç›®æ ‡é”å®šç‰¹æ•ˆç»„ ---
        createTargetVisuals();

        // --- 3. æ‰‹åŠ¿ ---
        setupHands();

        renderer.setAnimationLoop(render);
    }

    // åˆ›å»ºåå­—å‡†æ˜Ÿè´´å›¾
    function createCursorTexture() {
        const cvs = document.createElement('canvas');
        cvs.width = 128; cvs.height = 128;
        const c = cvs.getContext('2d');
        c.strokeStyle = '#ffffff';
        c.lineWidth = 6;
        c.beginPath();
        // åå­—
        c.moveTo(64, 20); c.lineTo(64, 108);
        c.moveTo(20, 64); c.lineTo(108, 64);
        c.stroke();
        // å¤–åœˆ
        c.beginPath();
        c.arc(64, 64, 40, 0, Math.PI*2);
        c.stroke();
        return new THREE.CanvasTexture(cvs);
    }

    // åˆ›å»ºé”å®šç‰¹æ•ˆ (æˆ˜æœ¯æ¡† + æŒ‡é’ˆ)
    function createTargetVisuals() {
        targetGroup = new THREE.Group();
        targetGroup.visible = false;
        scene.add(targetGroup);

        // A. æˆ˜æœ¯æ¡† (4ä¸ªLå‹è§’è½)
        const bracketGeo = new THREE.BufferGeometry();
        // å®šä¹‰ä¸€ä¸ªLå½¢çš„é¡¶ç‚¹
        const s = 0.3; // å¤§å°
        const vertices = new Float32Array([
            // å·¦ä¸Š
            -s, s, 0,  -s+0.1, s, 0,
            -s, s, 0,  -s, s-0.1, 0,
            // å³ä¸Š
            s, s, 0,   s-0.1, s, 0,
            s, s, 0,   s, s-0.1, 0,
            // å·¦ä¸‹
            -s, -s, 0, -s+0.1, -s, 0,
            -s, -s, 0, -s, -s+0.1, 0,
            // å³ä¸‹
            s, -s, 0,  s-0.1, -s, 0,
            s, -s, 0,  s, -s+0.1, 0
        ]);
        bracketGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        const bracketMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
        const brackets = new THREE.LineSegments(bracketGeo, bracketMat);
        targetGroup.add(brackets);

        // B. æ‰«ææ¿€å…‰é¢ (ä¸­é—´ä¸Šä¸‹æ‰«)
        const planeGeo = new THREE.PlaneGeometry(0.6, 0.02);
        const planeMat = new THREE.MeshBasicMaterial({ 
            color: 0xff3300, 
            transparent: true, 
            opacity: 0.5,
            side: THREE.DoubleSide
        });
        laserPlane = new THREE.Mesh(planeGeo, planeMat);
        targetGroup.add(laserPlane);

        // C. çº¯ç™½æŒ‡é’ˆ (å·¦å³)
        const ptrGeo = new THREE.ConeGeometry(0.05, 0.15, 4);
        const ptrMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // çº¯ç™½

        const leftPtr = new THREE.Mesh(ptrGeo, ptrMat);
        leftPtr.position.set(-0.5, 0, 0); 
        leftPtr.rotation.z = -Math.PI / 2;
        leftPtr.name = "leftPtr";
        targetGroup.add(leftPtr);

        const rightPtr = new THREE.Mesh(ptrGeo, ptrMat);
        rightPtr.position.set(0.5, 0, 0); 
        rightPtr.rotation.z = Math.PI / 2;
        rightPtr.name = "rightPtr";
        targetGroup.add(rightPtr);
    }

    function setupHands() {
        const handModelFactory = new XRHandModelFactory();
        function buildHand(idx) {
            const hand = renderer.xr.getHand(idx);
            hand.add(handModelFactory.createHandModel(hand, "mesh"));
            hand.addEventListener('connected', () => {
                hand.traverse(child => {
                    if(child.isMesh) {
                        // çº¢è‰²ç§‘æŠ€æ‰‹å¥—ç½‘æ ¼
                        child.material = new THREE.MeshBasicMaterial({
                            color: 0xff5500, wireframe: true, transparent: true, opacity: 0.3
                        });
                    }
                });
            });
            scene.add(hand);
            return hand;
        }
        handLeft = buildHand(0);
        handRight = buildHand(1);
    }

    // --- é«˜çº§ UI ç»˜åˆ¶ ---
    function updateCanvasUI(powerValue, label, isFinal) {
        ctx.clearRect(0, 0, 512, 256);

        // 1. èƒŒæ™¯ (åˆ‡è§’è®¾è®¡)
        ctx.fillStyle = THEME_BG;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(480, 0); ctx.lineTo(512, 32); // å³ä¸Šåˆ‡è§’
        ctx.lineTo(512, 256); ctx.lineTo(32, 256); ctx.lineTo(0, 224); // å·¦ä¸‹åˆ‡è§’
        ctx.closePath();
        ctx.fill();

        // 2. è¾¹æ¡†
        ctx.strokeStyle = isFinal ? "#ff0000" : "#ffaa00";
        ctx.lineWidth = 6;
        ctx.stroke();

        // 3. å†…éƒ¨è£…é¥°çº¿
        ctx.strokeStyle = "rgba(255, 100, 0, 0.3)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(20, 60); ctx.lineTo(492, 60); ctx.stroke();
        
        // 4. æ–‡å­—
        // æ•°å€¼
        ctx.font = "bold 100px Courier New";
        ctx.textAlign = "center";
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#ff0000";
        ctx.fillStyle = isFinal ? "#ffcccc" : THEME_COLOR;
        ctx.fillText(powerValue, 256, 160);

        // æ ‡ç­¾
        ctx.font = "bold 30px Arial";
        ctx.fillStyle = "#ffffff";
        ctx.shadowBlur = 0;
        ctx.fillText(isFinal ? "!! TARGET CONFIRMED !!" : "SCANNING TYPE-C...", 256, 210);

        // é¡¶éƒ¨å°å­—
        ctx.font = "20px Arial";
        ctx.fillStyle = "#ffaa00";
        ctx.textAlign = "left";
        ctx.fillText("BP-SCOUTER", 30, 40);
        ctx.textAlign = "right";
        ctx.fillText("VEGETA_UNIT", 480, 40);
    }

    // --- æ ¸å¿ƒäº¤äº’é€»è¾‘ ---
    function triggerScan(position) {
        if (isLocked) return;
        isLocked = true;
        aimCursor.visible = false;

        // 1. æ”¾ç½®æˆ˜æœ¯æ¡† (ç›´æ¥æ”¾åœ¨ç‚¹å‡»ç‚¹ï¼Œé¢å‘æ‘„åƒæœº)
        targetGroup.position.copy(position);
        targetGroup.lookAt(camera.position); // å§‹ç»ˆæ­£å¯¹ä½ çœ‹
        targetGroup.visible = true;

        // 2. æ”¾ç½® UI
        // é’ˆå¯¹è´å‰å¡”æ‰‹åŠçš„é«˜åº¦ä¼˜åŒ–ï¼š
        // å¦‚æœä½ ç‚¹çš„æ˜¯èƒ¸å£ï¼Œæˆ‘ä»¬å¸Œæœ› UI åœ¨å¤´é¡¶ã€‚æ‰‹åŠå‡è®¾é«˜ 1.5ç±³å·¦å³ã€‚
        // æˆ‘ä»¬æŠŠ UI æ”¾åœ¨ç‚¹å‡»ç‚¹ä¸Šæ–¹ 0.6ç±³å¤„ (ç¡®ä¿ä¸æŒ¡è„¸ï¼Œä¹Ÿä¸é£å¤ªé«˜)
        const uiPos = position.clone().add(new THREE.Vector3(0, 0.65, 0));

        if (powerSprite) scene.remove(powerSprite);
        const texture = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        powerSprite = new THREE.Sprite(mat);
        powerSprite.scale.set(1.0, 0.5, 1);
        powerSprite.position.copy(uiPos);
        scene.add(powerSprite);

        // 3. åŠ¨ç”»æµç¨‹
        let steps = 0;
        // è´å‰å¡”çš„æˆ˜æ–—åŠ› (å¸¸æ€ 18000, æ¢æµ‹å™¨é€šå¸¸åˆ° 20000+ çˆ†ç‚¸)
        const targetVal = 18000 + Math.floor(Math.random() * 4000); 

        scanInterval = setInterval(() => {
            steps++;
            const rnd = Math.floor(Math.random() * 22000);
            updateCanvasUI(rnd, "", false);
            texture.needsUpdate = true;

            // æˆ˜æœ¯æ¡†åŠ¨ç”»
            if (targetGroup.visible) {
                // æ¿€å…‰ä¸Šä¸‹æ‰«
                laserPlane.position.y = Math.sin(steps * 0.5) * 0.25;
            }

            if (steps > 40) { // 2ç§’
                clearInterval(scanInterval);
                updateCanvasUI(targetVal, "CONFIRMED", true);
                texture.needsUpdate = true;
                // çˆ†è¡¨ç‰¹æ•ˆï¼šå¦‚æœæˆ˜æ–—åŠ›è¿‡é«˜ï¼Œå˜çº¢
                if (targetVal > 20000) {
                    targetGroup.children[0].material.color.setHex(0xff0000);
                }
            }
        }, 50);
    }

    function resetSystem() {
        isLocked = false;
        clearInterval(scanInterval);
        targetGroup.visible = false;
        targetGroup.children[0].material.color.setHex(0xffffff); // æ¢å¤ç™½è‰²
        if (powerSprite) {
            scene.remove(powerSprite);
            powerSprite = null;
        }
        document.getElementById('hud-status').innerText = "SYSTEM READY";
    }

    // --- å§¿åŠ¿åˆ¤å®š (ä¿æŒä¸å˜) ---
    function isPointing(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;
        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        const middleTip = hand.joints['middle-finger-tip'].position;
        return wrist.distanceTo(indexTip) > 0.10 && wrist.distanceTo(middleTip) < 0.10;
    }

    function isFist(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;
        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        return wrist.distanceTo(indexTip) < 0.09;
    }

    // --- æ¸²æŸ“ ---
    function render(timestamp, frame) {
        if (frame) {
            const refSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();

            if (!hitTestSourceRequested) {
                session.requestReferenceSpace('viewer').then(ref => {
                    session.requestHitTestSource({ space: ref }).then(source => hitTestSource = source);
                });
                hitTestSourceRequested = true;
            }

            if (hitTestSource && !isLocked) {
                const hits = frame.getHitTestResults(hitTestSource);
                if (hits.length > 0) {
                    const pose = hits[0].getPose(refSpace);
                    aimCursor.visible = true;
                    // Sprite åªéœ€è¦ä½ç½®ï¼Œä¸éœ€è¦æ—‹è½¬ï¼ˆè‡ªåŠ¨é¢æœç›¸æœºï¼‰
                    aimCursor.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                } else {
                    aimCursor.visible = false;
                }
            }

            if (!isLocked && aimCursor.visible && isPointing(handRight)) {
                triggerScan(aimCursor.position);
            }
            if (isLocked && isFist(handLeft)) {
                resetSystem();
            }

            // å¾…æœºåŠ¨ç”»ï¼šå·¦å³ç™½è‰²æŒ‡é’ˆæµ®åŠ¨
            if (isLocked && targetGroup.visible) {
                const t = timestamp / 500;
                const left = targetGroup.getObjectByName("leftPtr");
                const right = targetGroup.getObjectByName("rightPtr");
                if(left && right) {
                    // å‘å†…æŒ¤å‹åŠ¨ç”»
                    const offset = 0.5 + Math.sin(t) * 0.05;
                    left.position.x = -offset;
                    right.position.x = offset;
                }
            }
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
