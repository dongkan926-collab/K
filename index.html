<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XR å®ä½“æµä½“</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 999;
        }
        h1 { margin-bottom: 20px; color: #00ffff; text-shadow: 0 0 10px #00ffff; }
        button {
            padding: 20px 60px; font-size: 24px; border-radius: 50px; border: none;
            background: linear-gradient(45deg, #00ff88, #00aaff); color: #000; font-weight: bold;
        }
    </style>
    <!-- ä½¿ç”¨ jsDelivr å¼•å…¥ Three.js -->
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<div id="launcher">
    <h1>ğŸ’  å®ä½“æµä½“æ¨¡å¼</h1>
    <button id="btn-enter">å¯åŠ¨ AR</button>
</div>

<script type="module">
    import * as THREE from 'three';

    let camera, scene, renderer;
    let hand1, hand2;
    let stage;

    // --- æ ¸å¿ƒå˜é‡ ---
    const PARTICLE_COUNT = 2000; // 2000ä¸ªå®ä½“çƒ
    let meshSystem; // InstancedMesh å¯¹è±¡
    const dummy = new THREE.Object3D(); // è¾…åŠ©å¯¹è±¡ï¼Œç”¨äºè®¡ç®—çŸ©é˜µ
    
    // ç‰©ç†æ•°ç»„
    const posOriginal = new Float32Array(PARTICLE_COUNT * 3);
    const position = new Float32Array(PARTICLE_COUNT * 3);
    const velocity = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    
    // æ‰‹éƒ¨æ•°æ®
    const handsData = [
        { pos: new THREE.Vector3(), vel: new THREE.Vector3(), lastPos: new THREE.Vector3(), active: false },
        { pos: new THREE.Vector3(), vel: new THREE.Vector3(), lastPos: new THREE.Vector3(), active: false }
    ];

    document.getElementById('btn-enter').addEventListener('click', onEnter);

    async function onEnter() {
        if (!navigator.xr) return alert("ä¸æ”¯æŒ XR");
        try {
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local'],
                optionalFeatures: ['hand-tracking']
            });
            document.getElementById('launcher').style.display = 'none';
            initThree(session);
        } catch (e) {
            alert("å¯åŠ¨å¤±è´¥: " + e.message);
        }
    }

    function initThree(session) {
        scene = new THREE.Scene();
        scene.background = null;

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.05, 100);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);

        session.addEventListener('end', () => {
            renderer.setAnimationLoop(null);
            document.getElementById('launcher').style.display = 'flex';
        });

        // --- èˆå°è®¾ç½® (å›ºå®šåœ¨é¢å‰ 0.5 ç±³) ---
        stage = new THREE.Group();
        stage.position.set(0, -0.2, -0.5); 
        scene.add(stage);

        // 1. ä¿ç•™çº¢æ¡† (ä½œä¸ºå®šä½å‚è€ƒ)
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.6, 0.6),
            new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, opacity: 0.2, transparent: true })
        );
        stage.add(box);

        // 2. åˆ›å»ºå®ä½“ç²’å­ç³»ç»Ÿ
        createSolidParticles();

        // 3. æ‰‹éƒ¨
        hand1 = renderer.xr.getHand(0); scene.add(hand1);
        hand2 = renderer.xr.getHand(1); scene.add(hand2);

        renderer.setAnimationLoop(render);
    }

    function createSolidParticles() {
        // ä½¿ç”¨ 20é¢ä½“å‡ ä½•ä½“ (çœ‹èµ·æ¥åƒåœ†çƒï¼Œä½†é¢æ•°å°‘ï¼Œæ€§èƒ½å¥½)
        // åŠå¾„ 0.006 (6æ¯«ç±³)
        const geometry = new THREE.IcosahedronGeometry(0.006, 0);
        
        // æè´¨ï¼šä½¿ç”¨ MeshBasicMaterial ç¡®ä¿ä¸å—å…‰ç…§å½±å“ï¼ˆæœ€äº®ï¼‰
        const material = new THREE.MeshBasicMaterial({
            color: 0xffffff,     // åŸºç¡€ç™½ï¼Œé¢œè‰²é€šè¿‡ instanceColor ä¿®æ”¹
            transparent: true,
            opacity: 0.8,        // åŠé€æ˜
            depthWrite: false,   // å…³é—­æ·±åº¦å†™å…¥ï¼Œå®ç°ç²’å­é‡å æ—¶çš„èåˆæ„Ÿ
            blending: THREE.NormalBlending // æ­£å¸¸æ··åˆï¼Œç¡®ä¿èƒ½çœ‹è§
        });

        meshSystem = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);
        meshSystem.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // æ ‡è®°ä¸ºåŠ¨æ€ï¼Œæå‡æ€§èƒ½
        
        // åˆå§‹åŒ–ä½ç½®å’Œé¢œè‰²
        const c1 = new THREE.Color(0x00ffff); // é’
        const c2 = new THREE.Color(0xff00ff); // ç´«

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // éšæœºåˆ†å¸ƒ
            const x = (Math.random() - 0.5) * 0.5;
            const y = (Math.random() - 0.5) * 0.5;
            const z = (Math.random() - 0.5) * 0.5;

            // å­˜å…¥ç‰©ç†æ•°ç»„
            posOriginal[i*3] = x; posOriginal[i*3+1] = y; posOriginal[i*3+2] = z;
            position[i*3] = x;    position[i*3+1] = y;    position[i*3+2] = z;
            velocity[i*3] = 0;    velocity[i*3+1] = 0;    velocity[i*3+2] = 0;

            // è®¾ç½®åˆå§‹çŸ©é˜µ
            dummy.position.set(x, y, z);
            dummy.updateMatrix();
            meshSystem.setMatrixAt(i, dummy.matrix);

            // è®¾ç½®é¢œè‰²
            const color = c1.clone().lerp(c2, Math.random());
            meshSystem.setColorAt(i, color);
        }

        stage.add(meshSystem);
    }

    // æ›´æ–°æ‰‹éƒ¨æ•°æ®
    function updateHand(hand, data) {
        if(hand && hand.joints && hand.joints['index-finger-tip']) {
            const joint = hand.joints['index-finger-tip'];
            if(joint.position.length() === 0) { data.active = false; return; }

            const worldPos = new THREE.Vector3();
            joint.getWorldPosition(worldPos);
            const localPos = worldPos.clone().sub(stage.position);
            
            data.active = true;
            data.pos.copy(localPos);
            
            if(data.lastPos.lengthSq() > 0) {
                // è®¡ç®—é€Ÿåº¦
                data.vel.copy(data.pos).sub(data.lastPos).multiplyScalar(2.0); // æ”¾å¤§ä¸€ç‚¹é€Ÿåº¦æ„Ÿ
            }
            data.lastPos.copy(data.pos);
        } else {
            data.active = false;
        }
    }

    function getGesture(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist'] || !hand.joints['middle-finger-tip']) return 'neutral';
        const d = hand.joints['wrist'].position.distanceTo(hand.joints['middle-finger-tip'].position);
        if (d < 0.08) return 'fist';
        if (d > 0.12) return 'palm';
        return 'neutral';
    }

    function render() {
        updateHand(hand1, handsData[0]);
        updateHand(hand2, handsData[1]);

        let gesture = 'neutral';
        const g1 = getGesture(hand1); const g2 = getGesture(hand2);
        if(g1 !== 'neutral') gesture = g1; else if(g2 !== 'neutral') gesture = g2;

        // ç‰©ç†å‚æ•°
        const returnForce = 0.02;
        const friction = 0.92;
        const interactRadiusSq = 0.12 * 0.12; // 12cm äº¤äº’èŒƒå›´

        // é¢œè‰²å¯¹è±¡ (ç”¨äºä¸´æ—¶è®¡ç®—)
        const tempColor = new THREE.Color();

        // å¾ªç¯æ‰€æœ‰ç²’å­
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            let px = position[ix];
            let py = position[ix+1];
            let pz = position[ix+2];
            let vx = velocity[ix];
            let vy = velocity[ix+1];
            let vz = velocity[ix+2];

            // 1. æ‰‹éƒ¨æµä½“äº¤äº’
            for(let h=0; h<2; h++) {
                if(handsData[h].active) {
                    const dx = px - handsData[h].pos.x;
                    const dy = py - handsData[h].pos.y;
                    const dz = pz - handsData[h].pos.z;
                    const dSq = dx*dx + dy*dy + dz*dz;

                    if(dSq < interactRadiusSq) {
                        const d = Math.sqrt(dSq);
                        const f = (1 - d / 0.12);

                        // æ–¥åŠ›
                        vx += (dx / d) * f * 0.004;
                        vy += (dy / d) * f * 0.004;
                        vz += (dz / d) * f * 0.004;
                        
                        // æ‹–æ‹½åŠ› (Flow)
                        vx += handsData[h].vel.x * f * 0.08;
                        vy += handsData[h].vel.y * f * 0.08;
                        vz += handsData[h].vel.z * f * 0.08;
                    }
                }
            }

            // 2. æ‰‹åŠ¿åŠ›åœº
            if(gesture === 'fist') {
                vx -= px * 0.03; vy -= py * 0.03; vz -= pz * 0.03; // å¼ºåŠ›èšåˆ
            } else if(gesture === 'palm') {
                vx += px * 0.02; vy += py * 0.02; vz += pz * 0.02; // çˆ†å‘
            } else {
                // ç¼“æ…¢å›å®¶
                vx += (posOriginal[ix] - px) * returnForce;
                vy += (posOriginal[ix+1] - py) * returnForce;
                vz += (posOriginal[ix+2] - pz) * returnForce;
            }

            // 3. ç‰©ç†åº”ç”¨
            vx *= friction; vy *= friction; vz *= friction;
            px += vx; py += vy; pz += vz;

            // å›å†™æ•°ç»„
            position[ix] = px; position[ix+1] = py; position[ix+2] = pz;
            velocity[ix] = vx; velocity[ix+1] = vy; velocity[ix+2] = vz;

            // 4. æ›´æ–° InstancedMesh çŸ©é˜µ
            dummy.position.set(px, py, pz);
            
            // ç®€å•çš„è‡ªè½¬ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
            dummy.rotation.x += vx * 5;
            dummy.rotation.y += vy * 5;
            
            dummy.updateMatrix();
            meshSystem.setMatrixAt(i, dummy.matrix);

            // 5. é¢œè‰²åŠ¨æ€å˜åŒ– (æ ¹æ®é€Ÿåº¦å˜äº®)
            const speed = Math.sqrt(vx*vx + vy*vy + vz*vz);
            if(gesture === 'palm') {
                tempColor.setHex(0xffaa00); // é‡‘
            } else if (gesture === 'fist') {
                tempColor.setHex(0xff0000); // çº¢
            } else {
                // é»˜è®¤è“ç´«ï¼Œé€Ÿåº¦è¶Šå¿«è¶Šç™½
                tempColor.setRGB(0, 1, 1).lerp(new THREE.Color(0xff00ff), Math.sin(i)*0.5+0.5);
                tempColor.lerp(new THREE.Color(0xffffff), Math.min(speed * 10, 1));
            }
            meshSystem.setColorAt(i, tempColor);
        }

        // æ ‡è®°æ›´æ–°
        meshSystem.instanceMatrix.needsUpdate = true;
        meshSystem.instanceColor.needsUpdate = true;

        // æ—‹è½¬çº¢æ¡†
        stage.children[0].rotation.y += 0.005;

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
